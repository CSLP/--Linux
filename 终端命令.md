# 一个命令就是一个程序
# 一切都是文件
# 命令输错了 Ctrl+u或者esc+backspace


***
## 目录各种操作
- ls(list) 目录1（路径） 目录2 
- ls -a=ls --all   . 当前目录 .. 上级目录
- ls -l  详细信息列表   total +表面大小（bytes）
    - 权限 链接数目（同inode号的文件数或目录内文件数） 文件所有者的名称 文件所在的群组 文件表面大小 最近一次修改的时间 名称
    - ls -lh  参数h:human readable :大小自动选用合适的单位显示
    - ls -lt     t:time            :按文件最近一次修改时间排序
- ls -i  显示文件的inode号（索引节点）
- du  disk usage 显示目录文件的真正大小
    - du 文件（路径）
    - du -h   human readable
    - du -a   默认只显示各个目录大小，加上 -a文件也会显示出来
    - du -s   s  sum 只显示总大小
- commad -p 10  commad -parameter=10
- Tab 补全
- history all command used
- clear=ctrl+L  Home=ctrl+a  End=ctrl+E  ,,,,,,,,,,
- hostname 主机名 whoami 用户名
- pwd pring working directory  
- which command 知道此命令的所对应的程序在哪里
- cd change directory    
- cd .. 回到上级目录  cd  回到家目录

***
## 对文件操作

### 读文件
- cat +文件（相对路径或绝对路径）   显示文件的所有内容
    - cat -n   给内容加行号
- less+文件   渐进显示文件内容       b/空格：上/下一页 y/回车：上/下一页   q：停止读文件，终止less命令
    - = 显示当前阅读的进度（包括阅读的是几行到几行之间，文件一共有多少行，阅读了多少个字符，一共有多少字符，阅读进度是百分之几）
    - h 显示帮助文档 q退出
    - / 进入搜索模式  n/N 下/上一个匹配结果
- head+文件 显示文件前十行
    - head -n x +文件 
- tail     显示文件尾十行
    - tail -n x
    - tail -f 默认一秒检查一下文件，实现实时追踪
    - tail -f -s x 每隔x秒检查一下
         
### 创建文件
- touch +文件（路径）
    - 文件存在 ，则touch 触碰，碰一下这个文件，让电脑认为我刚修改过（更改文件的时间戳）
    - 文件不存在，则创建此文件  touch 文件1 文件2 .....
- mkdir +目录     make directory
    - mkdir 目录1 目录2 ....
    - mkdir -p  one/two/three 递归创建目录  （创建一个目录one，里面有一个目录two。。
                 
### 拷贝移动重命名文件
- cp copy 拷贝文件或目录
     - 文件
     - cp file1  file2   在当前目录下创建file1的副本file2
     - cp file1  directory 在directory目录下创建file1的副本file1
     - cp file1  directory/file3 在directory目录下创建file1的副本file3
                 
     - 目录(目录，子目录和文件都被拷贝）
     - cp -R direcotry1 directory2
     - cp -R direcotry1 directory
     - cp -R direcotry1 directory/directory3
     - *号是很常用的正则表达式符号，被称为通配符
     - cp *.txt folder  把当前目录下所有txt文件拷贝到folder下
     - cp ha* folder    吧当前目录下所有ha开头的文件（只限文件）拷贝到folder下
- mv move 移动文件（目录）或重命名文件（目录）
     - mv file1 file2   把file1 “移动到”当前目录下成为file2，，，，就相当于重命名了
     - mv file directory 把file移动到directory（cp类似复制+粘贴，mv类似剪切+粘贴）
     - mv directory1 directory 把目录directory1移动到directory
     - mv *.txt folder
     - mv ha* folder
                 
### 删除文件或目录
- rm remove  rm file1 file2 file3,,,
     - rm -i file inform 通知告知，向用户确认是否要删除 y/n  是/否
     - rm -f file force  强迫，强制，不论如何，立即强制删除文件
     - rm -r directory recursive 递归的   递归删除目录
     - rmdir   只能删除空目录
            
### 链接文件（类似指针的概念）（linux的文件存储方式：文件名，文件内容，权限分别存储在不同地方
   - Physical link 物理链接或硬链接：链接起来的文件名指向相同的文件内容，它们的inode一样,只能链接两个文件
       - ln(link) file1 file2  (file1已存在，创建file1的硬链接file2）指向相同的文件内容，改file1则file2也会变，它们inode相同
   - Symbolic link 符号链接或软链接：可以链接文件或目录
       - ln  -s  file 1 file2 (symbolic,file1已存在，创建file1的软链接file2)，file2指向file1这个文件名，它们的inode不一样
         但他们的文件内容一样，修改一个另一个也会变，file2可以删，file1一删，file2就没指向了，产生错误
         
### 查找文件
 - locate(定位）命令，快速查找出包含关键字的所有文件和目录
     - locate 关键字(或正则表达式）
     - locate在文件数据库查找，而Linux一般每天更新一次数据库，所以刚创建的文件用locate查不到
     - updatedb   强制系统立即更新数据库，以便于locate查找新文件
 - find 在硬盘中查找
     - 用法：find 《何处》《何物》《做什么》
         - 何处：指定在哪个目录中查找。此目录的所有子目录也会被查找。与locate命令的查找所有文件数据库的所有记录不同，find命令可以限定查找目录，比如我们可以只让find查找/home目录。默认地，假如我们没有给出《何处》这个参数，那么find命令会在当前目录及其子目录中查找。
         - 何物：也就是要查找什么。我们可以根据文件的名字来查找，也可以根据其大小来查找，也可以根据其最近访问时间来查找，等等。这个参数是必须的
         - 做什么：用find命令找到我们要的文件后，可以对每个文件做一定的操作，称为“后续处理”。默认地，假如不指定这个参数，那么find命令只会显示找到的文件，不会做其他事情。
         - 根据名字找
             - find  -name file  在当前目录及子目录下找file
             - find /var/log    -name syslog  在/var/log  中找syslog，找不到不显示结果，有多个结果会一起显示
             - find /var/log    -name syslog*  在目录中找syslog开头的文件
             - find /var/log    -name *syslog*  在目录中找包含syslog关键字的文件
             - find   /   -name  syslog   在硬盘里查找syslog
         - 根据大小找
             - find /var   -size +10M   查找/var中大小大于10M的文件
             - find /var   -size - 10G    小于10G的文件
             - find /var   -size 10k     等于10KB的文件
         - 根据文件的最近访问时间找(-atime   acess time访问时间）
             - find -name *.jpg  -atime -7    找当前目录下最近7天内访问的jpg文件
         - 仅仅查找目录或文件（-type d ；只查找目录 -type f:只查文件）
             - find /var/log -name mysql -type d
             - find /var/log -name mysql -type f
         - 操作查找结果
             - find -name *.jpg=find -name *.jpg -print
             - -printf参数     print formatted格式化打印
                 - find ~/Photos -name *.jpg -printf "%p - %u\n",打印结果     文件名 - 文件的所有者（%p文件名，-就是短横，%u文件的所有者，\n换行）
             - find -name *.jpg  -delete  删除查找到的文件   
             - -exec命令  （execute）后接一个命令，对每个查找到的文件进行操作，若-exec换成-ok，用法一样，只不过-ok会对每一个查找的文件进行询问确认操作
                 - find -name  *.jpg -exec chmod 600 {} \;      所有找到的jpg文件权限都改为600（{}会用查找到的每个文件来替换，分号是必须的结尾）
                 
### 处理显示文件的数据
  1. 筛选数据
      - grep(Globally search a Regular Expressioon and Print 全局搜索一个正则表达式并且打印）在文件中查找关键字，并且显示关键字所在的行，可以配合正则表达式
          - grep text file  在file中搜索要搜索的文本text
              - grep "Hello World" file2   有空格用双引号
              - grep  alias  .bashrc
          - grep -i text file 忽略大小写
          - grep -I  text file 排除二进制文件
          - grep -n text file 显示搜索到的文本所在的行号
          - grep -v text file   显示没有text的行  （invert：颠倒，倒置）
          - grep -r text dectory=rgrep text directory  在目录递归地找    recurive
          - 配合regular expression（RE,regex,regexp) 的高级用法
              -RE使用单个字符串来描述、匹配一系列符合某个句法规则的字符串，下面是一些正则表达式字符
                  - .   匹配除\n之外的任何单个字符
                  - ^ 行首（匹配输入字符串的开始位置）
                  - $ 行尾（匹配输入字符串的结束位置）
                  - [] 在中括号中的任意一个字符
                  - ? 问号前面的元素出现零次或一次
                  - * 星号前面的元素可能出现零次，一次或多次
                  - + 加号前面的元素必须出现一次或一次以上
                  - | 逻辑或
                  - () 表达式的分组（表示范围和优先度）
              - grep -E=egrep  
                  - grep -E alias .bashrc     alias 也是一个RE    
                  - grep -E ^alias .bashrc   (^后面的字符一定要出现在行首位置）所以此处显示出现在行首位置的alias
                  - grep -E [Aa]lias .bashrc    相当于搜索alias和Alias
                  - grep -E [0-4] .bashrc    用于搜索包含0-4的任一数字的行
                  - grep -E [a-zA-Z]  .bashrc  用于搜索包含a-z和A-Z之间的任意字母的行
2. 文件排序
    - sort     对文件的行进行排序
        - sort file    不区分大小写的将文件中的行按照字典顺序排序
        - sort -o file2  file1   把file1中排序好的内容放在file2，file1内容不变（排序好的内容写入新文件）
        - sort -r  file 倒序排列  reverse相反，反面
        - sort -R file  随机排序，每次的顺序都不同
        - sort -n file  对数字按大小排列，不加-n则按字典排序（111<5）
3. 文件统计
    - wc      word count统计单词书目，行数，字符数，字节数等
        - wc file   结果显示  行数 单词数 字节数  文件名
        - wc -l  file 统计行数 line
        - wc -w file 统计单词数 word
        - wc -c file 统计字节数  character（一个英文字母一个字节，一个汉字两个字节）
        - wc -m file 统计字符数 （英文字母个数）
4. 删除文件中的重复内容
    - uniq  unique独一无二        只能将连续的重复行变为一行
        - uniq file2 file1        处理好的内容写入file1，我曹和sort那个正好相反沃日，原文件不变
        - uniq -c file   统计重复的行数
        - uniq -d file  只显示重复行的值
5.剪切文件的一部分内容
    - cut      用于对于文件的每一行进行剪切处理
        - cut -c 根据字符数来剪切
            - cut -c 2-4 file  file的 每一行只保留第2到4个字符
6. 总结，其实上面的所谓排序，删除，剪切只是准确来说是排序，删除，剪切了要显示的内容，文件的本身并没有改变

### 解压缩文件
  - 关于压缩
      - 打包：将多个文件变成一个总的文件，这个总的文件我们通常称为archive(归档，存档)
      - 压缩：是将一个大文件通过某些压缩算法变成一个小文件
      - 压缩步骤：
          - 用tar将多个文件归档为archive一个文件
          - 用gzip或bzip2将archive压缩
   - tar 只一个归档或者归档并压缩(调用gzip或bzip2)
       - tar -cvf tutorial.tar tutorial       把tutorial目录里的所有文件归成一个文件tutoria.tar(里面包括tutorial目录)
           - c   create 创建
           - v   verbose(冗长，详细，啰嗦)   会显示操作的细节
           - f file   指定归档文件
      - tar -cvf archive.tar file1 file2 file3 ....也可以把不同位置的文件进行归档(但不会有总目录)，但是最好归档之前先把所有文件放在一个目录下
      - tar -tf archive.tar    显示归档里的内容，但是不解开
      - tar -rvf archive.tar file    追加文件到归档
      - tar -xvf archive.tar    解开归档
          - x   extract 提取，拔出
      - tar -zcvf archive.tar.gz tutorial   归档，然后用gzip压缩
      - tar -zxvf archive.tar.gz  解开文档，解压缩
      - tar -jcvf  archive.tar.bz2 tutorial 同上
      - tar -jxvf  archive.tar.bz2 同上
  - gzip,bzip2:解压缩归档
      - gzip 比较常用，压缩后的后缀名  .tar.gz   
          - gzip archive.tar  压缩
          - gunzip archive.tar 解压
      - bzip2:压缩率更高，但更耗时       .tar.bz2
          - bzip2  archive.tar
          - bunzip2 archive.tar 解压
  - zcat,zmore,zless直接显示用gzip压缩的文件的内容(用发同cat,more,less)
  - zip,unzip;unrar  解压缩.zip,.rar 文件
      - .zip
          - unzip archive.zip 解压(安装sudo apt-get install unzip)
          - unzip -l archive.zip   不解压，只看
          - zip -r archive.zip    archive/(r必须加，否则只压缩个空文件夹)(安装sudo apt-get install zip)
     - .rar  
         - unrar e archive.rar 解压(e之前就是没短横，）(安装，sudo apt-get install unrar)
         - unrar l archive.rar 只看，不解压
         - 压缩要买收费软件
      
                                                      
         
         
***
## 权限操作

- sudo substitute user do  替换，代替，替身
    - sudo command 运行root用户的命令
    - sudo su    成为root用户
    - exit   退出root状态
    
### 用户和群组操作 （root）
- adduser  用户名      增加新用户,默认创建同名群组（debian一族，其他useradd，之后在设密码才能用）
 - passwd   用户名      修改相应用户的密码
 - usermod user modify 修改用户账户
      - usermod -l  newname   old name     修改用户的名字，但是用户家目录名字需要手动修改
      - usermod -g group user 将user从原来的群移动到group群组中
      - usermod -G group1,group2,group3 user  将用户添加到多个群组
      - usermod -aG group  user 不把用户从原来的群组删除同时让其加入别的群组（append,只能用aG,顺序不能变，且只能大写的才能配合a）
- groups user  显示用户所在的群组，可以有多个
- groups    显示当前用户所在的群组
- deluser   name       delete  user，只删除用户（debian，其他userdel)
     - deluser --remove-home name    删除用户和其目录
- addgroup    name   创建群组  (debian，其他groupadd)
- delgroup    group    删除群组（debian,其他groupdel)

### 关于文件和目录的权限（ls -l  列出的第一列)
- 分为四组数字，第一组一位，第二组三位，第三组三位，第四组三位，类似:drwxrwxrwx, root 用户可以读写，执行任意文件
     - 第一组
         - d: directory 表示这个文件是目录
         - l: link             表示这个文件是链接
         - -： 短线         表示这个文件是一般文件
      - 第二组：表示文件的所有者对于此文件的访问权限
         - r:read
         - w:write     写或删除的权限
         - x:execute   如果是文件，表示可执行，如果是目录（且有r权限）则表示可读可写
      - 第三组：表示文件所属的群组的其他用户对于此文件的访问权限
      - 第四组：表示除前两组之外的其他用户对于此文件的访问权限
 - 修改文件的访问权限（root可以，本文件的拥有者也可以）
     - chmod     change mod
         - 数字法 （chmod -R 递归的分配给目录及其所有子目录、文件权限，不加R的话只会给这个目录分配权限）
             - r:4,w:2,x:1    ---:0,r--:4,-w-:2,--x:1以此类推
             - chmod 777 file           相当于给file分配rwxrwxrwx权限
         - 字母法   (chmod -R 递归的分配给目录及其所有子目录、文件权限，不加R的话只会给这个目录分配权限）
             - u(user):所有者，g(group):群组其他用户，o(other):其他用户，a(all):所有用户
             - +：添加权限，-：去除权限，=：分配权限
             - chmod u+rx file    文件所有者加上rx权限
             - chmod o-r file        其他用户减去r权限
             - chmod g+r,o-r file    群组用户加上r权限，其他用户减去r权限
             - chmod go-r, ile     群组用户和其他用户减去r权限
             - chmod a+rw file=chmod +rw file  给所有用户加上rw权限
             - chmod u=rwx,g=r,o=- file    相当于分配   rwxr-----
             
             
*** 
## 软件安装（基于Debian一族）

### 背景
   - Package(软件包）：软件的所有文件的压缩包，二进制形式，包含了安装软件的所有指令。Debian一族后缀.deb,Red Hat一族（Redhat，Fedora,,).rpm后缀  
   - .deb包特点
       - 包括依赖关系
       - 所有包存在相同的地方---repository(软件仓库）
    - 依赖关系(dependency)：Linux上一个软件经常需要使用到其他程序或者其他程序的片段（库），这个软件依赖其他程序，这就是依赖关系。
    - Debian包管理程序自动寻找并安装要安装软件的依赖程序
    - repository：全球有很多个软件仓库（很多服务器),存的软件基本一样
        - 管理软件仓库
            - 查看/etc/apt/sources.list
            - deb开头：用于下载软件的二进制版本
            - deb-src:  用于下载软件源代码
            - 例如  deb http://ubuntu.cn99.com/ubuntu/   xenial   main   restricted
                - 网址表示你所选的软件仓库的服务器地址，可以修改
                - xenial表示ubuntu的版本代号，xenial是16.04的代号
                - main--官方支持的软件,restricted(受限)--非完全自由软件，universe(宇宙)--非官方、社区维护的软件，multiverse(多元宇宙)--非自由软件
            - 网址可直接修改，也可图形化修改
                - 找到software sources或software&update软件选择ubuntu software修改即可
 
 ###软件包管理(root)
 
  - apt
      - aptitude: 卸载软件是卸载不用的依赖
      - apt-get update :软件包缓存的更新（更新可安装的软件列表）
      - apt-cache search :搜索软件包  （在软件列表里搜索可用软件）      cache:高速缓存
      - apt-get install xxx  :安装，，，
      - apt -get autoremove xxx  :删除xxx
      - apt-get upgrade   升级所有已安装的软件包
  - dpkg :apt-get aptitude命令的后端（backend)命令,apt-get,aptitude是软件安装工具的后端
      - dpkg -i *.deb   安装本地的.deb 软件包
      - dpkg -r  包名  卸载
      
      
 ****
## 流，管道，重定向
1. 概念
    - 重定向(redirect)：简单来说就是我们可以把本来要显示在终端的命令结果输送到别的地方
    - 管道(pipeling)：把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就构成了管道
    - 命令的输出有三个去向
        - 终端
        - 文件
        - 其他命令的输入
    - 命令的输入有两个来源
        - 文件
        - 键盘
    - 特殊的文件形式：CSV(Comma Separated Values----逗号分隔值)格式，后缀名.csv通常可以被excel等打开，打开之后会把分隔符隔开的各个数值填充到表格里
        - 逗号分隔值（Comma-Separated Values,CSV,有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须想二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段见的分隔符是其他字符或字符创，最常见的是逗号或制表符号。通常，所有记录都有完全相同的字段序列。
    - 关于stdin,stdout,stderr  标准输入，输出，标准错误输出，默认输出到终端界面
        - stdin：标准输入流。英语standard input的缩写（standart是英语“标准”的意思，input是英语“输入”的意思）。标准输入是指输入至程序的数据（通常是文件）。程序要求以读(read)操作来传输数据。并非所有程序都要求输入。如dir或ls程序运行时不用任何输入。 除非重定向，输入是预期由键盘获取的。 标准输入的文件描述符为 0 （零）；POSIX <unistd.h> 的定义是 STDIN_FILENO；相对应的 <stdio.h> 变数为 FILE* stdin
        - stdout：标准输出流。英语standard output的缩写（output是英语“输出”的意思）。标准输出是指程序写输出数据的流。程序要求数据传输使用写的运算。并非所有程序都要求输出。如mv或ren程序在成功完成时是没有输出的。 除非重导向，输出是预期显示在终端上的。 标准输出的文件描述符为 1 （一）。POSIX <unistd.h> 定义是 STDOUT_FILENO；相对应的 <stdio.h> 变数为 FILE* stdout 。
        - stderr：标准错误输出流。英语standard error的缩写（error是英语“错误”的意思）。标准错误输出是另一个输出流，用于输出错误消息或诊断。它独立于标准输出，且标准输出和标准错误输出可以分别被重定向。标准错误输出的文件描述符为 2 （二）；POSIX <unistd.h> 定义为 STDERR_FILENO；相对的 <stdio.h> 变数 FILE* stderr。
        - 文件描述符   名字    解释
        - 0	stdin	标准输入
        - 1   stdout    标准输出
        - 2   stderr     标准错误输出
        - fd(File  Descirptor,文件描述符）文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向操作系统内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。文件描述符通常是Unix，Linux等系统的概念。在Windows中，也有类似的概念，但是Windows中称为《句柄》，就是handle。
2. 操作
     - 重定向输出
         - cut    例如一个notes.csv文件 每行的格式       name,  scores,comment
            - -d 参数  delimiter（分隔符）用于指定用什么分隔符
            - -f  参数 field 区域   表示剪切下用分隔符分隔的那一块或那几块区域
            - cut -d , -f 1 notes.csv  从成绩文件中剪切（显示）下名字的一列（即第一列）
            - cut -d , -f 1,3 notes.csv   第一和第三部分
            - cut -d , -f 2- notes.csv    第二部分直到最后的部分 
        - ">"将标准输出重定向到新的文件
            - cut -d , -f 1 notes.csv > file   剪切内容不显示在终端，直接重定向到file里，如果file不存在，那么创建一个，如果存在，则会覆盖掉file原来内容
            - 黑洞：/dev/null 特殊文件，不是一个目录，此文件具有唯一的属性，他总是空的。它能使发送到/dev/null的任何数据作废，就好像这些数据掉到了无底洞一般。
                - cut -d , -f 1 notes.csv > /dev/null   如果不需要在终端显示cut结果，也不想存储到文件里，可以这样做
        - ">>"将标准输出重定向到文件末尾
            - cut -d , -f 1 notes.csv >> file 文件不存在，创建文件，文件存在，不会覆盖，会把剪切内容追加到文件尾
        - 2>  将标准错误输出重定向到新文件（2是stderr的文件描述符）
            - cat file  >  results.txt 2> errors.log   假如file存在，则将其内容显示重定向到results.txt,若不存在，将其输出的错误信息重定向到errors.log，类似上面，不存在就创建，存在就覆盖
        - 2>> 将stderr重定向到文件末尾
        - 2>&1将stderr重定向到与stdout相同的地方
            - cat  nn > result.txt 2>&1   将cat  nn这个命令的所有输出都重定向到result.txt文件中
        - cat nn >> result.txt 2>&1  将cat nn 这个命令的所有输出都重定向到文件末尾
    - 重定向输入
        - "<" 从文件中读取
            - cat < notes.csv 运行结果和cat notes.csv 一样，但是原理不同
                - cat notes.csv ：这种情况下，cat命令接受的输入是notes.csv这个文件名，那么它要先打开notes.csv文件，然后打印出文件内容。
                - cat < notes.csv ：这种情况下，cat命令接受的输入直接是notes.csv这个文件的内容，cat命令只负责将其内容打印。而打开文件并将文件内容传递给cat命令的工作则交给shell程序（也就是控制终端的程序）来完成。
        - "<<"从键盘读取
            - sort -n << END  sort -n 接受键盘的输入进行排序，输入END（自己指定）结束输入
            - wc  -m  <<  END  wc -m 接受键盘的输入统计字符数，输入END结束
    - 管道 ------"|" 管道符号，建立管道命令，就是将一个命令的输出重定向为另一个命令的输入
         1.  cut -d , -f notes.csv | sort   cut的输出作为sort的输入
         2.  cut -d , -f notes.csv | sort > sorted.txt"  sort的输出又重定向到sorted.txt中
         3.   du  | sort -nr | head     du递归统计大小  -n数字排序 -r 倒序排序   head 只显示前十个
         4. sudo grep log -Ir /var/log | cut -d : -f 1 | sort | uniq


***
## 进程
### 查看进程---监视系统活动
  - w ：            Show who is logged on and what they are doing
      - 10:51:45 up 40 min,  1 user,  load average: 0.39, 0.43, 0.41
          - 分别表示当前时间，运行时间，一个用户，平均负载
          - 当前时间，也可以用date命令
          - up 40 min   运行时间啊为40分钟 up---uptime  用uptime（系统正常运行时间)命令也可以显示
          - 1 user  一个用户
          - load average(平均负载）从左到右分别表示。这些数值表示一段时间内的平均活跃进程（process）数，单核负载超过1就是过载，双核超过2过载，四核超过4过载，，，
              - 1分钟以内平均负载（0.39）
              - 5分钟之内的平均负载（0.43）
              
              - 15分钟之内的平均负载（0.41）
              - tload   绘制随时间变化的负载曲线图（横坐标时间，纵坐标负载大小）
      - USER           TTY        FROM             LOGIN@       IDLE         JCPU      PCPU      WHAT（登录的用户列表，显示当下的系统中连接的用户是那几位，他们在做什么任务，任务进行了多长时间了）
      - haineicu      tty7       :0                      10:12           58:57       1:23      0.18s     /sbin/upstart -
          - user 用户名
          - TTY Linux中默认提供了六个命令行终端和一个图形终端：tty1-tty7。其中tty1-tty6是真正终端，tty7是图形终端（也就是平时我们启动Ubuntu桌面版时默认登录的图形用户界面，也是全屏的）。Ubuntu中可以通过Ctrl+Alt+F1~F7切换这7个终端。除了这7个基本的大环境终端，我们还可以在tty7中开很多不是全屏的终端，也就是我们平时用来输入命令行的图形终端（ctrl + shift + T快捷键），这些终端的名字是以pts开头的。pts是pseudo terminal slave的缩写，表示“伪终端从属”。如果我新开一个图形终端，那么显示名称为pts/0，如上图中所示。如果我再开一个图形终端，那么它的名字就是pts/1。依次类推。
          - FROM 用户连接到的服务器的IP地址（或者主机名）。在我们的例子中，我们并没有登录远程服务器，只是在本地自己的电脑上测试，所以FROM那列显示的并不是实际的IP地址
          - LOGIN@ 用户什么时候登陆的
          - IDLE（idle不活跃的）  用户多久没活跃了   58:57 58分57秒没活跃了     2:12m   2小时12分钟没活跃了
          - JCPU The  JCPU  time  is the time used by all processes attached to the tty.It does not include past background jobs, but  does  include  currently running background jobs.
          - PCPU The  PCPU  time  is  the time used by the current process, named in the "what" field.
          - WHAT :当下用户正运行的程序（upstart n.暴发户，新贵 v.突然跳起，突然发起）
  - ps :(Process Status 进程状态) report a snapshot (快照)of the current processes
      - 进程(process)：简单来说，进程就是加载到内存中运行的程序，大多数程序运行是都只在内存中启动一个进程，也有程序会创建好多个进程
      - ps 进程的静态列表，不带参数使用时只会列出当前运行ps命令的用户在当前终端中所运行的进程。有好多进程是root用户运行的，就没列出来。还有的进程，虽然也是当前用户运行的，但不是在当前的终端里，所以也没列出来
          - PID （process identifier进程识别码）进程号，每个进程有唯一的进程号
          - TTY 进程运行所在的终端
          - TIME 进程运行了多久
          - CMD(Command)产生这个进程的程序名
      - ps -ef 列出所有用户在所有终端的所有进程
          - UID(User Idenitier)  运行进程的用户
          - PID 进程号
          - PPID(Parent PID)  此进程的父进程进程号
          - C(cpu)  cpu占用率
          - STIME(start time)  进程开始时间
          - TTY 所在终端
          - TIME 进程运行时间
          - CMD产生这个进程的程序名
      - ps -efH 以乔木状列出所有进程(方便看出父子进程关系）
      - ps -u  列出此用户运行的进程
  - top:display Linux processes(实时更新，可交互）
      - linux上进程有5种状态
          - 运行(正在运行或在运行队列中等待)
          - 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 
          - 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 
          - 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 
          - 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) 
      - ps，top工具标识进程的5种状态码: 
          - D 不可中断 uninterruptible sleep (usually IO)
          - R 运行 runnable (on run queue) 
          - S 中断 sleeping  
          - T 停止 traced or stopped 
          - Z 僵死 a defunct (”zombie”) process   (defunct---死人，停业  zombie---僵尸）
      - top 按照cpu使用率显示排在前面的一些进程，结果分析如下
          - 统计信息区(前五行是系统整体的统计信息)          
             - 第一行是任务队列信息同 uptime 命令的执行结果
             - 第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行.
                 - us 用户空间占用CPU百分比
                 - sy 内核空间占用CPU百分比
                 - ni 用户进程空间内改变过优先级的进程占用CPU百分比
                 - d 空闲CPU百分比
                 - wa 等待输入输出的CPU时间百分比
                 - hi
                 - si
             - 最后两行为内存信息
                 - Mem
                     - total 物理内存总量
                     - used 使用的物理内存总量
                     - free 空闲内存总量
                     - buffers 用作内核缓存的内存量
                 - swap 
                     - total 交换区总量
                     - used 使用的交换区总量
                     - free 空闲交换区总量
                     - cached 缓冲的交换区总量。cached 缓存。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。
         - 进程信息区
             - 信息显示
                 - PID 进程id
                 - PPID 父进程id
                 - RUSER Real user name
                 - UID 进程所有者的用户id
                 - USER 进程所有者的用户名
                 - GROUP 进程所有者的组名
                 - TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?
                 - PR 优先级   priority(优先级)
                 - NI nice值。负值表示高优先级，正值表示低优先级
                 - P 最后使用的CPU，仅在多CPU环境下有意义
                 - %CPU 上次更新到现在的CPU时间占用百分比(cpu使用率)
                 - TIME 进程使用的CPU时间总计，单位秒
                 - TIME+ 进程使用的CPU时间总计，单位1/100秒
                 - %MEM 进程使用的物理内存百分比
                 - VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
                 - SWAP 进程使用的虚拟内存中，被换出的大小，单位kb
                 - RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
                 - CODE 可执行代码占用的物理内存大小，单位kb
                 - DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
                 - SHR 共享内存大小，单位kb
                 - nFLT 页面错误次数
                 - nDRT 最后一次写入到现在，被修改过的页面数
                 - S 进程状态。
                     - D=不可中断的睡眠状态
                     - R=运行
                     - S=睡眠
                     - T=跟踪/停止
                     - Z=僵尸进程
                 - COMMAND 命令名/命令行
                 - WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名
                 - Flags 任务标志，参考 sched.h
                 - 默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。
             - 交互
                 - q：退出top

                 - h：显示帮助文档，也就是哪些按键可以使用。按下任意键返回。

                 - B：大写的B，加粗某些信息。

                 - f：在进程列表中添加或删除某些列。 

                 - F：改变进程列表排序所参照的列。默认情况下，是按照%CPU那一列来排序。

                 - u：依照用户来过滤显示。可以输入用户名，按回车。

                 - k：结束某个进程。会让你输入要结束的进程的PID。

                 - s：改变刷新页面的时间。默认地，页面每隔3秒刷新一次。
  
### 管理进程
#### 常规
  - 停止进程
      - Ctrl+C:停止终端中正在运行的进程(终端中复制粘贴Ctrl+Shift+C/V)
      - kill   结束一个进程
          - kill PID1 PID2 PID3  结束进程
          - kill -9 PID       强制立即结束进程
      - killall  结束统一程序的所有进程
          - killall  程序名
    - 关机，重启，halt，reboot都调用了shutdown命令shutdown可以做到定时关机，重启等等
        - halt(停)   关闭系统  = shutdown -h now
            - sudo halt
        - reboot  重启系统   = shutdown -r now
            - sudo reboot
        - poweroff 关机  =shutdown -p
        -  shutdown 是一个独立的命令，它的后面可以指定关机的时间和关机的message，shutdown -h 和 shutdown -p 也就是 halt 和 poweroff，所以，shutdown 就是个加了时间的 halt 或者是 poweroff。
        - h alt 是强制关机，而poweroff 会先给 ACPI （Advanced Configuration and Power Management Interface）一个命令，之后再关机
        - shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了
        - init是所有进程的祖先﹐它的进程号始终为1﹐所以发送TERM信号给init会终止所有的用户进程﹑守护进程等。shutdown 就是使用这种机制。init定义了8个运行级别(runlevel)，init 0为关机﹐init 1为重启。
#### 进程的前后台转换
  - 后台运行进程
      - & 在后台运行进程(进程与终端相关联，终端停止或用户登出，后台进程也停止)
          - command  &      例如输出信息 [1] 16252，分别表示此终端的后台进程的标号，因为是第一个后台进程，所以标号为1，后面是PID
      - nohup  使后台进程与终端分离   run a command  immune(免疫) to hangups ,with output to a non-tty(输出存放到一个非TTY中)
          - 当用户注销或者网络断开(远程登录网络断了)时，终端会收到HUP(hang up 挂断)信号从而关闭其所有子进程，终端被关闭时也会关闭其子进程。使用nohup命令使程序不受HUP信号影响
          - nohup command   输出信息：ignoring input and appending output to nohup.out
  - 程序前后台转换
      - Ctrl +Z 配合bg  :把 一个正在执行的命令转向后台
          - Ctrl+Z :转到后台，并暂停运行
          - bg (background背景，后台)  :将命令转入后台运行(但是一旦命令开始运行，没有机会输入bg)。假如命令已经在后台，并且暂停着，那么bg命令将其状态改为运行
              - bg  不加参数，默认作用于最近的一个后台进程
              - bg %x      作用于指定标号为x的进程
          - jobs  显示当前终端里后台进程状态
      - fg(foreground前景)：把后台停止的或正在运行的程序转到前台运行
        - fg  不加参数，默认作用于最近的一个后台进程
        - fg %x      作用于指定标号为x的进程
        
        
        
        
***
## 关于终端

### 虚拟终端screen
  - screen   用于在一个终端中打开多个虚拟终端
       - 这个程序通常没有在Linux发行版里预装(sudo apt-get install screen.)
       - screen 开一个虚拟终端并进入，在运行，再开一个
       - Ctrl+D或运行exit退出当前虚拟终端，一直关闭直到显示screen is terminating表明所有的虚拟终端都被关闭了
       - Ctrl+a(在screen中操作)(一下是对帮助页面的解释)
           - Ctrl+a(摁下再松开) + ?   显示帮助界面(在进行所有操作前都要先摁Ctrl a,那些操作区分大小写)
           - clear 表示创建一个新的虚拟终端(及先摁Ctrl a,在摁c)(c)
           - version显示版本号(v)
           - windows 显示当前虚拟终端的列表(^W等效于w(当然之前得先摁ctrl a))
               - bash表示终端的默认名字，*表示当前所在的终端
           - title  重命名当前虚拟终端的名字(A)
           - split(分裂)  分隔当前虚拟终端为多个小虚拟终端(S),操作一次，分为两个，再来一次，分为三个，，，，，，
               - ctrl a之后tab光标调到下半部分，之后Ctrl a之后c为这个部分创建虚拟终端，Ctrl a后X关闭分出来的终端
           - detach(分离，脱离) 使screen所有虚拟终端与当前实际终端分离，重回实际终端，screen在后台运行
               - screen -r +配合虚拟终端编号 重回虚拟终端(screen -ls 列出当前的所有分离了的虚拟终端标号)
 
### 终端命令的延时执行
  - date ：调节时间
      - date 输出当前时间
      - 定制date的输出 ，自定义其的输出，可以选择输出那部分信息，输出格式以及输出的顺序
          - date "+%H"   输出小时
          - date "+%H:%M:%S"  输出时分秒   20:46:38
          - date "+%H时%M分%S"   20时46分38秒，自定义
          - date "+%Y" 年
       - date修改时间
   - at   延时执行一个程序(只能执行一次)
       -  在指定时刻执行程序
           - at 17:12   之后会提示输入要执行的命令，回车继续，Ctrl  D结束，显示EOT(End of Transmission)
           - at 17:12 tomorrow
           - at 17:12  12/10/15  美国日期格式月/日/年
       - 在指定间隔之后执行程序
           - at now +10 minutes  10分钟之后执行 (minutes ,hours,days,weeks,months,years)
       - atq,atrm  列出和删除正在等待执行的at任务
           - atq(at queue)列出正在等待执行的at任务(每次用at延时执行的命令，at都会给它分配一个编号)
           - atrm  +编号        删除at任务(at remove)
   - sleep 
       - 用分号隔开多个命令，使其依次执行(不是管道)
       - touch file ; rm file       创建文件file，之后删除
       - touch file ; sleep 10 ; rm file  创建文件，等待10秒钟，删除这个文件
       - sleep 后数值默认表示秒数，可以用m,h,d(分，时，天)替换
           - touch file ; sleep 10m ;rm file
   - &&,||
       - 类似上面的分号的作用，区别在于，若是&&则前面的命令执行成功，后面的命令才执行，||前面的命令执行失败后面的命令才执行，；不管前面的命令执行成功与否后面的命令都执行
   - crontab  定时重复执行程序，ubuntu下默认安装
       - service cron start/stop/restart    启动，停止和重启动crontab
       - crontab其实只一个命令，用来读取和修改名为crontab的文件。这个crontab文件包含了你要定时执行的程序列表，也包含了执行的时刻
       - 实际上，有两个命令，一个叫crontab,一个叫cron。crontab修改crontab文件，cron用于实际执行定时的程序
       - 相关参数
           - -e:修改crontab文件，没有的话会创建一个
           - -l:显示crontab文件
           - -r:删除crontab文件
       - crontab命令格式    m  h  dom mon dow command--分钟，小时，号，月，周几，命令(在crontab中写要定时执行的命令)
       - 这五个区域要么用数字加符号填充，要么写上一个*号表示任何值
          - m   minutes
          -  h   hour
          - dom   day of month  就是几号
          - mon    month
          - dow day of week   就是周几
          - comman要执行的命令
          - 例子
              - 47 * * * * command	 每个小时的47分都执行command命令，也就是 00点47, 01点47, 02点47, 等等
              - 0 0 * * 1 command	每个礼拜一的凌晨都执行command命令
              - 30 5 1-15 * * command	每个月的1~15日的5点30分都执行command命令
              - 0 0 * * 1,3,4 command	每个礼拜一，礼拜三，礼拜四的凌晨都执行command命令
              - 0 */2 * * * command	每2个小时的整点（0，2，4，6，等等）都执行command命令
              - */10 * * * 1-5 command	每个礼拜一到礼拜五的每个10的倍数的分钟（0，10，20，等等）都执行command命令
              - 你可以自己设计出很多很多不同的组合用法，来实现你的定时程序。
   
   
   

   
           
           
           
       
               
           
           
       
      
        
          
          
  

    
    
            
        
    
    

            
        
    
    
 
    
         
                 
                 


           


        
       
