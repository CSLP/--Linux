# 一个命令就是一个程序
# 一切都是文件
# Ctrl+c  终止程序
# 命令输错了 Ctrl+u或者esc+backspace
- date

***
## 目录各种操作
- ls(list) 目录1（路径） 目录2 
- ls -a=ls --all   . 当前目录 .. 上级目录
- ls -l  详细信息列表   total +表面大小（bytes）
    - 权限 链接数目（同inode号的文件数或目录内文件数） 文件所有者的名称 文件所在的群组 文件表面大小 最近一次修改的时间 名称
    - ls -lh  参数h:human readable :大小自动选用合适的单位显示
    - ls -lt     t:time            :按文件最近一次修改时间排序
- ls -i  显示文件的inode号（索引节点）
- du  disk usage 显示目录文件的真正大小
    - du 文件（路径）
    - du -h   human readable
    - du -a   默认只显示各个目录大小，加上 -a文件也会显示出来
    - du -s   s  sum 只显示总大小
- commad -p 10  commad -parameter=10
- Tab 补全
- history all command used
- clear=ctrl+L  Home=ctrl+a  End=ctrl+E  ,,,,,,,,,,
- hostname 主机名 whoami 用户名
- pwd pring working directory  
- which command 知道此命令的所对应的程序在哪里
- cd change directory    
- cd .. 回到上级目录  cd  回到家目录

***
## 对文件操作

### 读文件
- cat +文件（相对路径或绝对路径）   显示文件的所有内容
    - cat -n   给内容加行号
- less+文件   渐进显示文件内容       b/空格：上/下一页 y/回车：上/下一页   q：停止读文件，终止less命令
    - = 显示当前阅读的进度（包括阅读的是几行到几行之间，文件一共有多少行，阅读了多少个字符，一共有多少字符，阅读进度是百分之几）
    - h 显示帮助文档 q退出
    - / 进入搜索模式  n/N 下/上一个匹配结果
- head+文件 显示文件前十行
    - head -n x +文件 
- tail     显示文件尾十行
    - tail -n x
    - tail -f 默认一秒检查一下文件，实现实时追踪
    - tail -f -s x 每隔x秒检查一下
         
### 创建文件
- touch +文件（路径）
    - 文件存在 ，则touch 触碰，碰一下这个文件，让电脑认为我刚修改过（更改文件的时间戳）
    - 文件不存在，则创建此文件  touch 文件1 文件2 .....
- mkdir +目录     make directory
    - mkdir 目录1 目录2 ....
    - mkdir -p  one/two/three 递归创建目录  （创建一个目录one，里面有一个目录two。。
                 
### 拷贝移动重命名文件
- cp copy 拷贝文件或目录
     - 文件
     - cp file1  file2   在当前目录下创建file1的副本file2
     - cp file1  directory 在directory目录下创建file1的副本file1
     - cp file1  directory/file3 在directory目录下创建file1的副本file3
                 
     - 目录(目录，子目录和文件都被拷贝）
     - cp -R direcotry1 directory2
     - cp -R direcotry1 directory
     - cp -R direcotry1 directory/directory3
     - *号是很常用的正则表达式符号，被称为通配符
     - cp *.txt folder  把当前目录下所有txt文件拷贝到folder下
     - cp ha* folder    吧当前目录下所有ha开头的文件（只限文件）拷贝到folder下
- mv move 移动文件（目录）或重命名文件（目录）
     - mv file1 file2   把file1 “移动到”当前目录下成为file2，，，，就相当于重命名了
     - mv file directory 把file移动到directory（cp类似复制+粘贴，mv类似剪切+粘贴）
     - mv directory1 directory 把目录directory1移动到directory
     - mv *.txt folder
     - mv ha* folder
                 
### 删除文件或目录
- rm remove  rm file1 file2 file3,,,
     - rm -i file inform 通知告知，向用户确认是否要删除 y/n  是/否
     - rm -f file force  强迫，强制，不论如何，立即强制删除文件
     - rm -r directory recursive 递归的   递归删除目录
     - rmdir   只能删除空目录
            
### 链接文件（类似指针的概念）（linux的文件存储方式：文件名，文件内容，权限分别存储在不同地方
   - Physical link 物理链接或硬链接：链接起来的文件名指向相同的文件内容，它们的inode一样,只能链接两个文件
       - ln(link) file1 file2  (file1已存在，创建file1的硬链接file2）指向相同的文件内容，改file1则file2也会变，它们inode相同
   - Symbolic link 符号链接或软链接：可以链接文件或目录
       - ln  -s  file 1 file2 (symbolic,file1已存在，创建file1的软链接file2)，file2指向file1这个文件名，它们的inode不一样
         但他们的文件内容一样，修改一个另一个也会变，file2可以删，file1一删，file2就没指向了，产生错误
         
### 查找文件
 - locate(定位）命令，快速查找出包含关键字的所有文件和目录
     - locate 关键字(或正则表达式）
     - locate在文件数据库查找，而Linux一般每天更新一次数据库，所以刚创建的文件用locate查不到
     - updatedb   强制系统立即更新数据库，以便于locate查找新文件
 - find 在硬盘中查找
     - 用法：find 《何处》《何物》《做什么》
         - 何处：指定在哪个目录中查找。此目录的所有子目录也会被查找。与locate命令的查找所有文件数据库的所有记录不同，find命令可以限定查找目录，比如我们可以只让find查找/home目录。默认地，假如我们没有给出《何处》这个参数，那么find命令会在当前目录及其子目录中查找。
         - 何物：也就是要查找什么。我们可以根据文件的名字来查找，也可以根据其大小来查找，也可以根据其最近访问时间来查找，等等。这个参数是必须的
         - 做什么：用find命令找到我们要的文件后，可以对每个文件做一定的操作，称为“后续处理”。默认地，假如不指定这个参数，那么find命令只会显示找到的文件，不会做其他事情。
         - 根据名字找
             - find  -name file  在当前目录及子目录下找file
             - find /var/log    -name syslog  在/var/log  中找syslog，找不到不显示结果，有多个结果会一起显示
             - find /var/log    -name syslog*  在目录中找syslog开头的文件
             - find /var/log    -name *syslog*  在目录中找包含syslog关键字的文件
             - find   /   -name  syslog   在硬盘里查找syslog
         - 根据大小找
             - find /var   -size +10M   查找/var中大小大于10M的文件
             - find /var   -size - 10G    小于10G的文件
             - find /var   -size 10k     等于10KB的文件
         - 根据文件的最近访问时间找(-atime   acess time访问时间）
             - find -name *.jpg  -atime -7    找当前目录下最近7天内访问的jpg文件
         - 仅仅查找目录或文件（-type d ；只查找目录 -type f:只查文件）
             - find /var/log -name mysql -type d
             - find /var/log -name mysql -type f
         - 操作查找结果
             - find -name *.jpg=find -name *.jpg -print
             - -printf参数     print formatted格式化打印
                 - find ~/Photos -name *.jpg -printf "%p - %u\n",打印结果     文件名 - 文件的所有者（%p文件名，-就是短横，%u文件的所有者，\n换行）
             - find -name *.jpg  -delete  删除查找到的文件   
             - -exec命令  （execute）后接一个命令，对每个查找到的文件进行操作，若-exec换成-ok，用法一样，只不过-ok会对每一个查找的文件进行询问确认操作
                 - find -name  *.jpg -exec chmod 600 {} \;      所有找到的jpg文件权限都改为600（{}会用查找到的每个文件来替换，分号是必须的结尾）
                 
### 处理显示文件的数据
  1. 筛选数据
      - grep(Globally search a Regular Expressioon and Print 全局搜索一个正则表达式并且打印）在文件中查找关键字，并且显示关键字所在的行，可以配合正则表达式
          - grep text file  在file中搜索要搜索的文本text
              - grep "Hello World" file2   有空格用双引号
              - grep  alias  .bashrc
          - grep -i text file 忽略大小写
          - grep -I  text file 排除二进制文件
          - grep -n text file 显示搜索到的文本所在的行号
          - grep -v text file   显示没有text的行  （invert：颠倒，倒置）
          - grep -r text dectory=rgrep text directory  在目录递归地找    recurive
          - 配合regular expression（RE,regex,regexp) 的高级用法
              -RE使用单个字符串来描述、匹配一系列符合某个句法规则的字符串，下面是一些正则表达式字符
                  - .   匹配除\n之外的任何单个字符
                  - ^ 行首（匹配输入字符串的开始位置）
                  - $ 行尾（匹配输入字符串的结束位置）
                  - [] 在中括号中的任意一个字符
                  - ? 问号前面的元素出现零次或一次
                  - * 星号前面的元素可能出现零次，一次或多次
                  - + 加号前面的元素必须出现一次或一次以上
                  - | 逻辑或
                  - () 表达式的分组（表示范围和优先度）
              - grep -E=egrep  
                  - grep -E alias .bashrc     alias 也是一个RE    
                  - grep -E ^alias .bashrc   (^后面的字符一定要出现在行首位置）所以此处显示出现在行首位置的alias
                  - grep -E [Aa]lias .bashrc    相当于搜索alias和Alias
                  - grep -E [0-4] .bashrc    用于搜索包含0-4的任一数字的行
                  - grep -E [a-zA-Z]  .bashrc  用于搜索包含a-z和A-Z之间的任意字母的行
2. 文件排序
    - sort     对文件的行进行排序
        - sort file    不区分大小写的将文件中的行按照字典顺序排序
        - sort -o file2  file1   把file1中排序好的内容放在file2，file1内容不变（排序好的内容写入新文件）
        - sort -r  file 倒序排列  reverse相反，反面
        - sort -R file  随机排序，每次的顺序都不同
        - sort -n file  对数字按大小排列，不加-n则按字典排序（111<5）
3. 文件统计
    - wc      word count统计单词书目，行数，字符数，字节数等
        - wc file   结果显示  行数 单词数 字节数  文件名
        - wc -l  file 统计行数 line
        - wc -w file 统计单词数 word
        - wc -c file 统计字节数  character（一个英文字母一个字节，一个汉字两个字节）
        - wc -m file 统计字符数 （英文字母个数）
4. 删除文件中的重复内容
    - uniq  unique独一无二        只能将连续的重复行变为一行
        - uniq file2 file1        处理好的内容写入file1，我曹和sort那个正好相反沃日，原文件不变
        - uniq -c file   统计重复的行数
        - uniq -d file  只显示重复行的值
5.剪切文件的一部分内容
    - cut      用于对于文件的每一行进行剪切处理
        - cut -c 根据字符数来剪切
            - cut -c 2-4 file  file的 每一行只保留第2到4个字符
6. 总结，其实上面的所谓排序，删除，剪切只是准确来说是排序，删除，剪切了要显示的内容，文件的本身并没有改变
                                                      
         
         
***
## 权限操作

- sudo substitute user do  替换，代替，替身
    - sudo command 运行root用户的命令
    - sudo su    成为root用户
    - exit   退出root状态
    
### 用户和群组操作 （root）
- adduser  用户名      增加新用户,默认创建同名群组（debian一族，其他useradd，之后在设密码才能用）
 - passwd   用户名      修改相应用户的密码
 - usermod user modify 修改用户账户
      - usermod -l  newname   old name     修改用户的名字，但是用户家目录名字需要手动修改
      - usermod -g group user 将user从原来的群移动到group群组中
      - usermod -G group1,group2,group3 user  将用户添加到多个群组
      - usermod -aG group  user 不把用户从原来的群组删除同时让其加入别的群组（append,只能用aG,顺序不能变，且只能大写的才能配合a）
- groups user  显示用户所在的群组，可以有多个
- groups    显示当前用户所在的群组
- deluser   name       delete  user，只删除用户（debian，其他userdel)
     - deluser --remove-home name    删除用户和其目录
- addgroup    name   创建群组  (debian，其他groupadd)
- delgroup    group    删除群组（debian,其他groupdel)

### 关于文件和目录的权限（ls -l  列出的第一列)
- 分为四组数字，第一组一位，第二组三位，第三组三位，第四组三位，类似:drwxrwxrwx, root 用户可以读写，执行任意文件
     - 第一组
         - d: directory 表示这个文件是目录
         - l: link             表示这个文件是链接
         - -： 短线         表示这个文件是一般文件
      - 第二组：表示文件的所有者对于此文件的访问权限
         - r:read
         - w:write     写或删除的权限
         - x:execute   如果是文件，表示可执行，如果是目录（且有r权限）则表示可读可写
      - 第三组：表示文件所属的群组的其他用户对于此文件的访问权限
      - 第四组：表示除前两组之外的其他用户对于此文件的访问权限
 - 修改文件的访问权限（root可以，本文件的拥有者也可以）
     - chmod     change mod
         - 数字法 （chmod -R 递归的分配给目录及其所有子目录、文件权限，不加R的话只会给这个目录分配权限）
             - r:4,w:2,x:1    ---:0,r--:4,-w-:2,--x:1以此类推
             - chmod 777 file           相当于给file分配rwxrwxrwx权限
         - 字母法   (chmod -R 递归的分配给目录及其所有子目录、文件权限，不加R的话只会给这个目录分配权限）
             - u(user):所有者，g(group):群组其他用户，o(other):其他用户，a(all):所有用户
             - +：添加权限，-：去除权限，=：分配权限
             - chmod u+rx file    文件所有者加上rx权限
             - chmod o-r file        其他用户减去r权限
             - chmod g+r,o-r file    群组用户加上r权限，其他用户减去r权限
             - chmod go-r, ile     群组用户和其他用户减去r权限
             - chmod a+rw file=chmod +rw file  给所有用户加上rw权限
             - chmod u=rwx,g=r,o=- file    相当于分配   rwxr-----
             
             
*** 
## 软件安装（基于Debian一族）

### 背景
   - Package(软件包）：软件的所有文件的压缩包，二进制形式，包含了安装软件的所有指令。Debian一族后缀.deb,Red Hat一族（Redhat，Fedora,,).rpm后缀  
   - .deb包特点
       - 包括依赖关系
       - 所有包存在相同的地方---repository(软件仓库）
    - 依赖关系(dependency)：Linux上一个软件经常需要使用到其他程序或者其他程序的片段（库），这个软件依赖其他程序，这就是依赖关系。
    - Debian包管理程序自动寻找并安装要安装软件的依赖程序
    - repository：全球有很多个软件仓库（很多服务器),存的软件基本一样
        - 管理软件仓库
            - 查看/etc/apt/sources.list
            - deb开头：用于下载软件的二进制版本
            - deb-src:  用于下载软件源代码
            - 例如  deb http://ubuntu.cn99.com/ubuntu/   xenial   main   restricted
                - 网址表示你所选的软件仓库的服务器地址，可以修改
                - xenial表示ubuntu的版本代号，xenial是16.04的代号
                - main--官方支持的软件,restricted(受限)--非完全自由软件，universe(宇宙)--非官方、社区维护的软件，multiverse(多元宇宙)--非自由软件
            - 网址可直接修改，也可图形化修改
                - 找到software sources或software&update软件选择ubuntu software修改即可
 
 ###软件包管理(root)
 
  - apt
      - aptitude: 卸载软件是卸载不用的依赖
      - apt-get update :软件包缓存的更新（更新可安装的软件列表）
      - apt-cache search :搜索软件包  （在软件列表里搜索可用软件）      cache:高速缓存
      - apt-get install xxx  :安装，，，
      - apt -get autoremove xxx  :删除xxx
      - apt-get upgrade   升级所有已安装的软件包
  - dpkg :apt-get aptitude命令的后端（backend)命令,apt-get,aptitude是软件安装工具的后端
      - dpkg -i *.deb   安装本地的.deb 软件包
      - dpkg -r  包名  卸载
      
      
 ****
## 流，管道，重定向
1. 概念
    - 重定向(redirect)：简单来说就是我们可以把本来要显示在终端的命令结果输送到别的地方
    - 管道(pipeling)：把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就构成了管道
    - 命令的输出有三个去向
        - 终端
        - 文件
        - 其他命令的输入
    - 命令的输入有两个来源
        - 文件
        - 键盘
    - 特殊的文件形式：CSV(Comma Separated Values----逗号分隔值)格式，后缀名.csv通常可以被excel等打开，打开之后会把分隔符隔开的各个数值填充到表格里
        - 逗号分隔值（Comma-Separated Values,CSV,有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须想二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段见的分隔符是其他字符或字符创，最常见的是逗号或制表符号。通常，所有记录都有完全相同的字段序列。
    - 关于stdin,stdout,stderr  标准输入，输出，标准错误输出，默认输出到终端界面
        - stdin：标准输入流。英语standard input的缩写（standart是英语“标准”的意思，input是英语“输入”的意思）。标准输入是指输入至程序的数据（通常是文件）。程序要求以读(read)操作来传输数据。并非所有程序都要求输入。如dir或ls程序运行时不用任何输入。 除非重定向，输入是预期由键盘获取的。 标准输入的文件描述符为 0 （零）；POSIX <unistd.h> 的定义是 STDIN_FILENO；相对应的 <stdio.h> 变数为 FILE* stdin
        - stdout：标准输出流。英语standard output的缩写（output是英语“输出”的意思）。标准输出是指程序写输出数据的流。程序要求数据传输使用写的运算。并非所有程序都要求输出。如mv或ren程序在成功完成时是没有输出的。 除非重导向，输出是预期显示在终端上的。 标准输出的文件描述符为 1 （一）。POSIX <unistd.h> 定义是 STDOUT_FILENO；相对应的 <stdio.h> 变数为 FILE* stdout 。
        - stderr：标准错误输出流。英语standard error的缩写（error是英语“错误”的意思）。标准错误输出是另一个输出流，用于输出错误消息或诊断。它独立于标准输出，且标准输出和标准错误输出可以分别被重定向。标准错误输出的文件描述符为 2 （二）；POSIX <unistd.h> 定义为 STDERR_FILENO；相对的 <stdio.h> 变数 FILE* stderr。
        - 文件描述符   名字    解释
        - 0	stdin	标准输入
        - 1   stdout    标准输出
        - 2   stderr     标准错误输出
        - fd(File  Descirptor,文件描述符）文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向操作系统内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。文件描述符通常是Unix，Linux等系统的概念。在Windows中，也有类似的概念，但是Windows中称为《句柄》，就是handle。
2. 操作
     - 重定向输出
         - cut    例如一个notes.csv文件 每行的格式       name,  scores,comment
            - -d 参数  delimiter（分隔符）用于指定用什么分隔符
            - -f  参数 field 区域   表示剪切下用分隔符分隔的那一块或那几块区域
            - cut -d , -f 1 notes.csv  从成绩文件中剪切（显示）下名字的一列（即第一列）
            - cut -d , -f 1,3 notes.csv   第一和第三部分
            - cut -d , -f 2- notes.csv    第二部分直到最后的部分 
        - ">"将标准输出重定向到新的文件
            - cut -d , -f 1 notes.csv > file   剪切内容不显示在终端，直接重定向到file里，如果file不存在，那么创建一个，如果存在，则会覆盖掉file原来内容
            - 黑洞：/dev/null 特殊文件，不是一个目录，此文件具有唯一的属性，他总是空的。它能使发送到/dev/null的任何数据作废，就好像这些数据掉到了无底洞一般。
                - cut -d , -f 1 notes.csv > /dev/null   如果不需要在终端显示cut结果，也不想存储到文件里，可以这样做
        - ">>"将标准输出重定向到文件末尾
            - cut -d , -f 1 notes.csv >> file 文件不存在，创建文件，文件存在，不会覆盖，会把剪切内容追加到文件尾
        - 2>  将标准错误输出重定向到新文件（2是stderr的文件描述符）
            - cat file  >  results.txt 2> errors.log   假如file存在，则将其内容显示重定向到results.txt,若不存在，将其输出的错误信息重定向到errors.log，类似上面，不存在就创建，存在就覆盖
        - 2>> 将stderr重定向到文件末尾
        - 2>&1将stderr重定向到与stdout相同的地方
            - cat  nn > result.txt 2>&1   将cat  nn这个命令的所有输出都重定向到result.txt文件中
        - cat nn >> result.txt 2>&1  将cat nn 这个命令的所有输出都重定向到文件末尾
    - 重定向输入
        - "<" 从文件中读取
            - cat < notes.csv 运行结果和cat notes.csv 一样，但是原理不同
                - cat notes.csv ：这种情况下，cat命令接受的输入是notes.csv这个文件名，那么它要先打开notes.csv文件，然后打印出文件内容。
                - cat < notes.csv ：这种情况下，cat命令接受的输入直接是notes.csv这个文件的内容，cat命令只负责将其内容打印。而打开文件并将文件内容传递给cat命令的工作则交给shell程序（也就是控制终端的程序）来完成。
        - "<<"从键盘读取
            - sort -n << END  sort -n 接受键盘的输入进行排序，输入END（自己指定）结束输入
            - wc  -m  <<  END  wc -m 接受键盘的输入统计字符数，输入END结束
    - 管道 ------"|" 管道符号，建立管道命令，就是将一个命令的输出重定向为另一个命令的输入
         1.  cut -d , -f notes.csv | sort   cut的输出作为sort的输入
         2.  cut -d , -f notes.csv | sort > sorted.txt"  sort的输出又重定向到sorted.txt中
         3.   du  | sort -nr | head     du递归统计大小  -n数字排序 -r 倒序排序   head 只显示前十个
         4. sudo grep log -Ir /var/log | cut -d : -f 1 | sort | uniq

            
        
    
    

            
        
    
    
 
    
         
                 
                 


           


        
       
