# 一个命令就是一个程序
# 一切都是文件
# 命令输错了 Ctrl+u或者esc+backspace


***
## 目录各种操作
- ls(list) 目录1（路径） 目录2 
- ls -a=ls --all   . 当前目录 .. 上级目录
- ls -l  详细信息列表   total +表面大小（bytes）
    - 权限 链接数目（同inode号的文件数或目录内文件数） 文件所有者的名称 文件所在的群组 文件表面大小 最近一次修改的时间 名称
    - ls -lh  参数h:human readable :大小自动选用合适的单位显示
    - ls -lt     t:time            :按文件最近一次修改时间排序
- ls -i  显示文件的inode号（索引节点）
- du  disk usage 显示目录文件的真正大小
    - du 文件（路径）
    - du -h   human readable
    - du -a   默认只显示各个目录大小，加上 -a文件也会显示出来
    - du -s   s  sum 只显示总大小
- commad -p 10  commad -parameter=10
- Tab 补全
- history all command used
- clear=ctrl+L  Home=ctrl+a  End=ctrl+E  ,,,,,,,,,,
- hostname 主机名 whoami 用户名
- pwd pring working directory  
- which command 知道此命令的所对应的程序在哪里
- cd change directory    
- cd .. 回到上级目录  cd  回到家目录

***
## 对文件操作

### 读文件
- cat +文件（相对路径或绝对路径）   显示文件的所有内容
    - cat -n   给内容加行号
- less+文件   渐进显示文件内容       b/空格：上/下一页 y/回车：上/下一页   q：停止读文件，终止less命令
    - = 显示当前阅读的进度（包括阅读的是几行到几行之间，文件一共有多少行，阅读了多少个字符，一共有多少字符，阅读进度是百分之几）
    - h 显示帮助文档 q退出
    - / 进入搜索模式  n/N 下/上一个匹配结果
- head+文件 显示文件前十行
    - head -n x +文件 
- tail     显示文件尾十行
    - tail -n x
    - tail -f 默认一秒检查一下文件，实现实时追踪
    - tail -f -s x 每隔x秒检查一下
         
### 创建文件
- touch +文件（路径）
    - 文件存在 ，则touch 触碰，碰一下这个文件，让电脑认为我刚修改过（更改文件的时间戳）
    - 文件不存在，则创建此文件  touch 文件1 文件2 .....
- mkdir +目录     make directory
    - mkdir 目录1 目录2 ....
    - mkdir -p  one/two/three 递归创建目录  （创建一个目录one，里面有一个目录two。。
                 
### 拷贝移动重命名文件
- cp copy 拷贝文件或目录
     - 文件
     - cp file1  file2   在当前目录下创建file1的副本file2
     - cp file1  directory 在directory目录下创建file1的副本file1
     - cp file1  directory/file3 在directory目录下创建file1的副本file3
                 
     - 目录(目录，子目录和文件都被拷贝）
     - cp -R direcotry1 directory2
     - cp -R direcotry1 directory
     - cp -R direcotry1 directory/directory3
     - *号是很常用的正则表达式符号，被称为通配符
     - cp *.txt folder  把当前目录下所有txt文件拷贝到folder下
     - cp ha* folder    吧当前目录下所有ha开头的文件（只限文件）拷贝到folder下
- mv move 移动文件（目录）或重命名文件（目录）
     - mv file1 file2   把file1 “移动到”当前目录下成为file2，，，，就相当于重命名了
     - mv file directory 把file移动到directory（cp类似复制+粘贴，mv类似剪切+粘贴）
     - mv directory1 directory 把目录directory1移动到directory
     - mv *.txt folder
     - mv ha* folder
                 
### 删除文件或目录
- rm remove  rm file1 file2 file3,,,
     - rm -i file inform 通知告知，向用户确认是否要删除 y/n  是/否
     - rm -f file force  强迫，强制，不论如何，立即强制删除文件
     - rm -r directory recursive 递归的   递归删除目录
     - rmdir   只能删除空目录
            
### 链接文件（类似指针的概念）（linux的文件存储方式：文件名，文件内容，权限分别存储在不同地方
   - Physical link 物理链接或硬链接：链接起来的文件名指向相同的文件内容，它们的inode一样,只能链接两个文件
       - ln(link) file1 file2  (file1已存在，创建file1的硬链接file2）指向相同的文件内容，改file1则file2也会变，它们inode相同
   - Symbolic link 符号链接或软链接：可以链接文件或目录
       - ln  -s  file 1 file2 (symbolic,file1已存在，创建file1的软链接file2)，file2指向file1这个文件名，它们的inode不一样
         但他们的文件内容一样，修改一个另一个也会变，file2可以删，file1一删，file2就没指向了，产生错误
         
### 查找文件
 - locate(定位）命令，快速查找出包含关键字的所有文件和目录
     - locate 关键字(或正则表达式）
     - locate在文件数据库查找，而Linux一般每天更新一次数据库，所以刚创建的文件用locate查不到
     - updatedb   强制系统立即更新数据库，以便于locate查找新文件
 - find 在硬盘中查找
     - 用法：find 《何处》《何物》《做什么》
         - 何处：指定在哪个目录中查找。此目录的所有子目录也会被查找。与locate命令的查找所有文件数据库的所有记录不同，find命令可以限定查找目录，比如我们可以只让find查找/home目录。默认地，假如我们没有给出《何处》这个参数，那么find命令会在当前目录及其子目录中查找。
         - 何物：也就是要查找什么。我们可以根据文件的名字来查找，也可以根据其大小来查找，也可以根据其最近访问时间来查找，等等。这个参数是必须的
         - 做什么：用find命令找到我们要的文件后，可以对每个文件做一定的操作，称为“后续处理”。默认地，假如不指定这个参数，那么find命令只会显示找到的文件，不会做其他事情。
         - 根据名字找
             - find  -name file  在当前目录及子目录下找file
             - find /var/log    -name syslog  在/var/log  中找syslog，找不到不显示结果，有多个结果会一起显示
             - find /var/log    -name syslog*  在目录中找syslog开头的文件
             - find /var/log    -name *syslog*  在目录中找包含syslog关键字的文件
             - find   /   -name  syslog   在硬盘里查找syslog
         - 根据大小找
             - find /var   -size +10M   查找/var中大小大于10M的文件
             - find /var   -size - 10G    小于10G的文件
             - find /var   -size 10k     等于10KB的文件
         - 根据文件的最近访问时间找(-atime   acess time访问时间）
             - find -name *.jpg  -atime -7    找当前目录下最近7天内访问的jpg文件
         - 仅仅查找目录或文件（-type d ；只查找目录 -type f:只查文件）
             - find /var/log -name mysql -type d
             - find /var/log -name mysql -type f
         - 操作查找结果
             - find -name *.jpg=find -name *.jpg -print
             - -printf参数     print formatted格式化打印
                 - find ~/Photos -name *.jpg -printf "%p - %u\n",打印结果     文件名 - 文件的所有者（%p文件名，-就是短横，%u文件的所有者，\n换行）
             - find -name *.jpg  -delete  删除查找到的文件   
             - -exec命令  （execute）后接一个命令，对每个查找到的文件进行操作，若-exec换成-ok，用法一样，只不过-ok会对每一个查找的文件进行询问确认操作
                 - find -name  *.jpg -exec chmod 600 {} \;      所有找到的jpg文件权限都改为600（{}会用查找到的每个文件来替换，分号是必须的结尾）
                 
### 处理显示文件的数据
  1. 筛选数据
      - grep(Globally search a Regular Expressioon and Print 全局搜索一个正则表达式并且打印）在文件中查找关键字，并且显示关键字所在的行，可以配合正则表达式
          - grep text file  在file中搜索要搜索的文本text
              - grep "Hello World" file2   有空格用双引号
              - grep  alias  .bashrc
          - grep -i text file 忽略大小写
          - grep -I  text file 排除二进制文件
          - grep -n text file 显示搜索到的文本所在的行号
          - grep -v text file   显示没有text的行  （invert：颠倒，倒置）
          - grep -r text dectory=rgrep text directory  在目录递归地找    recurive
          - 配合regular expression（RE,regex,regexp) 的高级用法
              -RE使用单个字符串来描述、匹配一系列符合某个句法规则的字符串，下面是一些正则表达式字符
                  - .   匹配除\n之外的任何单个字符
                  - ^ 行首（匹配输入字符串的开始位置）
                  - $ 行尾（匹配输入字符串的结束位置）
                  - [] 在中括号中的任意一个字符
                  - ? 问号前面的元素出现零次或一次
                  - * 星号前面的元素可能出现零次，一次或多次
                  - + 加号前面的元素必须出现一次或一次以上
                  - | 逻辑或
                  - () 表达式的分组（表示范围和优先度）
              - grep -E=egrep  
                  - grep -E alias .bashrc     alias 也是一个RE    
                  - grep -E ^alias .bashrc   (^后面的字符一定要出现在行首位置）所以此处显示出现在行首位置的alias
                  - grep -E [Aa]lias .bashrc    相当于搜索alias和Alias
                  - grep -E [0-4] .bashrc    用于搜索包含0-4的任一数字的行
                  - grep -E [a-zA-Z]  .bashrc  用于搜索包含a-z和A-Z之间的任意字母的行
2. 文件排序
    - sort     对文件的行进行排序
        - sort file    不区分大小写的将文件中的行按照字典顺序排序
        - sort -o file2  file1   把file1中排序好的内容放在file2，file1内容不变（排序好的内容写入新文件）
        - sort -r  file 倒序排列  reverse相反，反面
        - sort -R file  随机排序，每次的顺序都不同
        - sort -n file  对数字按大小排列，不加-n则按字典排序（111<5）
3. 文件统计
    - wc      word count统计单词书目，行数，字符数，字节数等
        - wc file   结果显示  行数 单词数 字节数  文件名
        - wc -l  file 统计行数 line
        - wc -w file 统计单词数 word
        - wc -c file 统计字节数  character（一个英文字母一个字节，一个汉字两个字节）
        - wc -m file 统计字符数 （英文字母个数）
4. 删除文件中的重复内容
    - uniq  unique独一无二        只能将连续的重复行变为一行
        - uniq file2 file1        处理好的内容写入file1，我曹和sort那个正好相反沃日，原文件不变
        - uniq -c file   统计重复的行数
        - uniq -d file  只显示重复行的值
5.剪切文件的一部分内容
    - cut      用于对于文件的每一行进行剪切处理
        - cut -c 根据字符数来剪切
            - cut -c 2-4 file  file的 每一行只保留第2到4个字符
6. 总结，其实上面的所谓排序，删除，剪切只是准确来说是排序，删除，剪切了要显示的内容，文件的本身并没有改变

### 解压缩文件
  - 关于压缩
      - 打包：将多个文件变成一个总的文件，这个总的文件我们通常称为archive(归档，存档)
      - 压缩：是将一个大文件通过某些压缩算法变成一个小文件
      - 压缩步骤：
          - 用tar将多个文件归档为archive一个文件
          - 用gzip或bzip2将archive压缩
   - tar 只一个归档或者归档并压缩(调用gzip或bzip2)
       - tar -cvf tutorial.tar tutorial       把tutorial目录里的所有文件归成一个文件tutoria.tar(里面包括tutorial目录)
           - c   create 创建
           - v   verbose(冗长，详细，啰嗦)   会显示操作的细节
           - f file   指定归档文件
      - tar -cvf archive.tar file1 file2 file3 ....也可以把不同位置的文件进行归档(但不会有总目录)，但是最好归档之前先把所有文件放在一个目录下
      - tar -tf archive.tar    显示归档里的内容，但是不解开
      - tar -rvf archive.tar file    追加文件到归档
      - tar -xvf archive.tar    解开归档
          - x   extract 提取，拔出
      - tar -zcvf archive.tar.gz tutorial   归档，然后用gzip压缩
      - tar -zxvf archive.tar.gz  解开文档，解压缩
      - tar -jcvf  archive.tar.bz2 tutorial 同上
      - tar -jxvf  archive.tar.bz2 同上
  - gzip,bzip2:解压缩归档
      - gzip 比较常用，压缩后的后缀名  .tar.gz   
          - gzip archive.tar  压缩
          - gunzip archive.tar 解压
      - bzip2:压缩率更高，但更耗时       .tar.bz2
          - bzip2  archive.tar
          - bunzip2 archive.tar 解压
  - zcat,zmore,zless直接显示用gzip压缩的文件的内容(用发同cat,more,less)
  - zip,unzip;unrar  解压缩.zip,.rar 文件
      - .zip
          - unzip archive.zip 解压(安装sudo apt-get install unzip)
          - unzip -l archive.zip   不解压，只看
          - zip -r archive.zip    archive/(r必须加，否则只压缩个空文件夹)(安装sudo apt-get install zip)
     - .rar  
         - unrar e archive.rar 解压(e之前就是没短横，）(安装，sudo apt-get install unrar)
         - unrar l archive.rar 只看，不解压
         - 压缩要买收费软件
      
                                                      
         
         
***
## 权限操作

- sudo substitute user do  替换，代替，替身
    - sudo command 运行root用户的命令
    - sudo su    成为root用户
    - exit   退出root状态
    
### 用户和群组操作 （root）
- adduser  用户名      增加新用户,默认创建同名群组（debian一族，其他useradd，之后在设密码才能用）
 - passwd   用户名      修改相应用户的密码
 - usermod user modify 修改用户账户
      - usermod -l  newname   old name     修改用户的名字，但是用户家目录名字需要手动修改
      - usermod -g group user 将user从原来的群移动到group群组中
      - usermod -G group1,group2,group3 user  将用户添加到多个群组
      - usermod -aG group  user 不把用户从原来的群组删除同时让其加入别的群组（append,只能用aG,顺序不能变，且只能大写的才能配合a）
- groups user  显示用户所在的群组，可以有多个
- groups    显示当前用户所在的群组
- deluser   name       delete  user，只删除用户（debian，其他userdel)
     - deluser --remove-home name    删除用户和其目录
- addgroup    name   创建群组  (debian，其他groupadd)
- delgroup    group    删除群组（debian,其他groupdel)

### 关于文件和目录的权限（ls -l  列出的第一列)
- 分为四组数字，第一组一位，第二组三位，第三组三位，第四组三位，类似:drwxrwxrwx, root 用户可以读写，执行任意文件
     - 第一组
         - d: directory 表示这个文件是目录
         - l: link             表示这个文件是链接
         - -： 短线         表示这个文件是一般文件
      - 第二组：表示文件的所有者对于此文件的访问权限
         - r:read
         - w:write     写或删除的权限
         - x:execute   如果是文件，表示可执行，如果是目录（且有r权限）则表示可读可写
      - 第三组：表示文件所属的群组的其他用户对于此文件的访问权限
      - 第四组：表示除前两组之外的其他用户对于此文件的访问权限
 - 修改文件的访问权限（root可以，本文件的拥有者也可以）
     - chmod     change mod
         - 数字法 （chmod -R 递归的分配给目录及其所有子目录、文件权限，不加R的话只会给这个目录分配权限）
             - r:4,w:2,x:1    ---:0,r--:4,-w-:2,--x:1以此类推
             - chmod 777 file           相当于给file分配rwxrwxrwx权限
         - 字母法   (chmod -R 递归的分配给目录及其所有子目录、文件权限，不加R的话只会给这个目录分配权限）
             - u(user):所有者，g(group):群组其他用户，o(other):其他用户，a(all):所有用户
             - +：添加权限，-：去除权限，=：分配权限
             - chmod u+rx file    文件所有者加上rx权限
             - chmod o-r file        其他用户减去r权限
             - chmod g+r,o-r file    群组用户加上r权限，其他用户减去r权限
             - chmod go-r, ile     群组用户和其他用户减去r权限
             - chmod a+rw file=chmod +rw file  给所有用户加上rw权限
             - chmod u=rwx,g=r,o=- file    相当于分配   rwxr-----
             
             
*** 
## 软件安装（基于Debian一族）

### 背景
   - Package(软件包）：软件的所有文件的压缩包，二进制形式，包含了安装软件的所有指令。Debian一族后缀.deb,Red Hat一族（Redhat，Fedora,,).rpm后缀  
   - .deb包特点
       - 包括依赖关系
       - 所有包存在相同的地方---repository(软件仓库）
    - 依赖关系(dependency)：Linux上一个软件经常需要使用到其他程序或者其他程序的片段（库），这个软件依赖其他程序，这就是依赖关系。
    - Debian包管理程序自动寻找并安装要安装软件的依赖程序
    - repository：全球有很多个软件仓库（很多服务器),存的软件基本一样
        - 管理软件仓库
            - 查看/etc/apt/sources.list
            - deb开头：用于下载软件的二进制版本
            - deb-src:  用于下载软件源代码
            - 例如  deb http://ubuntu.cn99.com/ubuntu/   xenial   main   restricted
                - 网址表示你所选的软件仓库的服务器地址，可以修改
                - xenial表示ubuntu的版本代号，xenial是16.04的代号
                - main--官方支持的软件,restricted(受限)--非完全自由软件，universe(宇宙)--非官方、社区维护的软件，multiverse(多元宇宙)--非自由软件
            - 网址可直接修改，也可图形化修改
                - 找到software sources或software&update软件选择ubuntu software修改即可
 
 ###软件包管理(root)
 
  - apt
      - aptitude: 卸载软件是卸载不用的依赖
      - apt-get update :软件包缓存的更新（更新可安装的软件列表）
      - apt-cache search :搜索软件包  （在软件列表里搜索可用软件）      cache:高速缓存
      - apt-get install xxx  :安装，，，
      - apt -get autoremove xxx  :删除xxx
      - apt-get upgrade   升级所有已安装的软件包
  - dpkg :apt-get aptitude命令的后端（backend)命令,apt-get,aptitude是软件安装工具的后端
      - dpkg -i *.deb   安装本地的.deb 软件包
      - dpkg -r  包名  卸载
      
      
 ****
## 流，管道，重定向
1. 概念
    - 重定向(redirect)：简单来说就是我们可以把本来要显示在终端的命令结果输送到别的地方
    - 管道(pipeling)：把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就构成了管道
    - 命令的输出有三个去向
        - 终端
        - 文件
        - 其他命令的输入
    - 命令的输入有两个来源
        - 文件
        - 键盘
    - 特殊的文件形式：CSV(Comma Separated Values----逗号分隔值)格式，后缀名.csv通常可以被excel等打开，打开之后会把分隔符隔开的各个数值填充到表格里
        - 逗号分隔值（Comma-Separated Values,CSV,有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须想二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段见的分隔符是其他字符或字符创，最常见的是逗号或制表符号。通常，所有记录都有完全相同的字段序列。
    - 关于stdin,stdout,stderr  标准输入，输出，标准错误输出，默认输出到终端界面
        - stdin：标准输入流。英语standard input的缩写（standart是英语“标准”的意思，input是英语“输入”的意思）。标准输入是指输入至程序的数据（通常是文件）。程序要求以读(read)操作来传输数据。并非所有程序都要求输入。如dir或ls程序运行时不用任何输入。 除非重定向，输入是预期由键盘获取的。 标准输入的文件描述符为 0 （零）；POSIX <unistd.h> 的定义是 STDIN_FILENO；相对应的 <stdio.h> 变数为 FILE* stdin
        - stdout：标准输出流。英语standard output的缩写（output是英语“输出”的意思）。标准输出是指程序写输出数据的流。程序要求数据传输使用写的运算。并非所有程序都要求输出。如mv或ren程序在成功完成时是没有输出的。 除非重导向，输出是预期显示在终端上的。 标准输出的文件描述符为 1 （一）。POSIX <unistd.h> 定义是 STDOUT_FILENO；相对应的 <stdio.h> 变数为 FILE* stdout 。
        - stderr：标准错误输出流。英语standard error的缩写（error是英语“错误”的意思）。标准错误输出是另一个输出流，用于输出错误消息或诊断。它独立于标准输出，且标准输出和标准错误输出可以分别被重定向。标准错误输出的文件描述符为 2 （二）；POSIX <unistd.h> 定义为 STDERR_FILENO；相对的 <stdio.h> 变数 FILE* stderr。
        - 文件描述符   名字    解释
        - 0	stdin	标准输入
        - 1   stdout    标准输出
        - 2   stderr     标准错误输出
        - fd(File  Descirptor,文件描述符）文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向操作系统内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。文件描述符通常是Unix，Linux等系统的概念。在Windows中，也有类似的概念，但是Windows中称为《句柄》，就是handle。
2. 操作
     - 重定向输出
         - cut    例如一个notes.csv文件 每行的格式       name,  scores,comment
            - -d 参数  delimiter（分隔符）用于指定用什么分隔符
            - -f  参数 field 区域   表示剪切下用分隔符分隔的那一块或那几块区域
            - cut -d , -f 1 notes.csv  从成绩文件中剪切（显示）下名字的一列（即第一列）
            - cut -d , -f 1,3 notes.csv   第一和第三部分
            - cut -d , -f 2- notes.csv    第二部分直到最后的部分 
        - ">"将标准输出重定向到新的文件
            - cut -d , -f 1 notes.csv > file   剪切内容不显示在终端，直接重定向到file里，如果file不存在，那么创建一个，如果存在，则会覆盖掉file原来内容
            - 黑洞：/dev/null 特殊文件，不是一个目录，此文件具有唯一的属性，他总是空的。它能使发送到/dev/null的任何数据作废，就好像这些数据掉到了无底洞一般。
                - cut -d , -f 1 notes.csv > /dev/null   如果不需要在终端显示cut结果，也不想存储到文件里，可以这样做
        - ">>"将标准输出重定向到文件末尾
            - cut -d , -f 1 notes.csv >> file 文件不存在，创建文件，文件存在，不会覆盖，会把剪切内容追加到文件尾
        - 2>  将标准错误输出重定向到新文件（2是stderr的文件描述符）
            - cat file  >  results.txt 2> errors.log   假如file存在，则将其内容显示重定向到results.txt,若不存在，将其输出的错误信息重定向到errors.log，类似上面，不存在就创建，存在就覆盖
        - 2>> 将stderr重定向到文件末尾
        - 2>&1将stderr重定向到与stdout相同的地方
            - cat  nn > result.txt 2>&1   将cat  nn这个命令的所有输出都重定向到result.txt文件中
        - cat nn >> result.txt 2>&1  将cat nn 这个命令的所有输出都重定向到文件末尾
    - 重定向输入
        - "<" 从文件中读取
            - cat < notes.csv 运行结果和cat notes.csv 一样，但是原理不同
                - cat notes.csv ：这种情况下，cat命令接受的输入是notes.csv这个文件名，那么它要先打开notes.csv文件，然后打印出文件内容。
                - cat < notes.csv ：这种情况下，cat命令接受的输入直接是notes.csv这个文件的内容，cat命令只负责将其内容打印。而打开文件并将文件内容传递给cat命令的工作则交给shell程序（也就是控制终端的程序）来完成。
        - "<<"从键盘读取
            - sort -n << END  sort -n 接受键盘的输入进行排序，输入END（自己指定）结束输入
            - wc  -m  <<  END  wc -m 接受键盘的输入统计字符数，输入END结束
    - 管道 ------"|" 管道符号，建立管道命令，就是将一个命令的输出重定向为另一个命令的输入
         1.  cut -d , -f notes.csv | sort   cut的输出作为sort的输入
         2.  cut -d , -f notes.csv | sort > sorted.txt"  sort的输出又重定向到sorted.txt中
         3.   du  | sort -nr | head     du递归统计大小  -n数字排序 -r 倒序排序   head 只显示前十个
         4. sudo grep log -Ir /var/log | cut -d : -f 1 | sort | uniq


***
## 进程
### 查看进程---监视系统活动
  - w ：            Show who is logged on and what they are doing
      - 10:51:45 up 40 min,  1 user,  load average: 0.39, 0.43, 0.41
          - 分别表示当前时间，运行时间，一个用户，平均负载
          - 当前时间，也可以用date命令
          - up 40 min   运行时间啊为40分钟 up---uptime  用uptime（系统正常运行时间)命令也可以显示
          - 1 user  一个用户
          - load average(平均负载）从左到右分别表示。这些数值表示一段时间内的平均活跃进程（process）数，单核负载超过1就是过载，双核超过2过载，四核超过4过载，，，
              - 1分钟以内平均负载（0.39）
              - 5分钟之内的平均负载（0.43）
              
              - 15分钟之内的平均负载（0.41）
              - tload   绘制随时间变化的负载曲线图（横坐标时间，纵坐标负载大小）
      - USER           TTY        FROM             LOGIN@       IDLE         JCPU      PCPU      WHAT（登录的用户列表，显示当下的系统中连接的用户是那几位，他们在做什么任务，任务进行了多长时间了）
      - haineicu      tty7       :0                      10:12           58:57       1:23      0.18s     /sbin/upstart -
          - user 用户名
          - TTY Linux中默认提供了六个命令行终端和一个图形终端：tty1-tty7。其中tty1-tty6是真正终端，tty7是图形终端（也就是平时我们启动Ubuntu桌面版时默认登录的图形用户界面，也是全屏的）。Ubuntu中可以通过Ctrl+Alt+F1~F7切换这7个终端。除了这7个基本的大环境终端，我们还可以在tty7中开很多不是全屏的终端，也就是我们平时用来输入命令行的图形终端（ctrl + shift + T快捷键），这些终端的名字是以pts开头的。pts是pseudo terminal slave的缩写，表示“伪终端从属”。如果我新开一个图形终端，那么显示名称为pts/0，如上图中所示。如果我再开一个图形终端，那么它的名字就是pts/1。依次类推。
          - FROM 用户连接到的服务器的IP地址（或者主机名）。在我们的例子中，我们并没有登录远程服务器，只是在本地自己的电脑上测试，所以FROM那列显示的并不是实际的IP地址
          - LOGIN@ 用户什么时候登陆的
          - IDLE（idle不活跃的）  用户多久没活跃了   58:57 58分57秒没活跃了     2:12m   2小时12分钟没活跃了
          - JCPU The  JCPU  time  is the time used by all processes attached to the tty.It does not include past background jobs, but  does  include  currently running background jobs.
          - PCPU The  PCPU  time  is  the time used by the current process, named in the "what" field.
          - WHAT :当下用户正运行的程序（upstart n.暴发户，新贵 v.突然跳起，突然发起）
  - ps :(Process Status 进程状态) report a snapshot (快照)of the current processes
      - 进程(process)：简单来说，进程就是加载到内存中运行的程序，大多数程序运行是都只在内存中启动一个进程，也有程序会创建好多个进程
      - ps 进程的静态列表，不带参数使用时只会列出当前运行ps命令的用户在当前终端中所运行的进程。有好多进程是root用户运行的，就没列出来。还有的进程，虽然也是当前用户运行的，但不是在当前的终端里，所以也没列出来
          - PID （process identifier进程识别码）进程号，每个进程有唯一的进程号
          - TTY 进程运行所在的终端
          - TIME 进程运行了多久
          - CMD(Command)产生这个进程的程序名
      - ps -ef 列出所有用户在所有终端的所有进程
          - UID(User Idenitier)  运行进程的用户
          - PID 进程号
          - PPID(Parent PID)  此进程的父进程进程号
          - C(cpu)  cpu占用率
          - STIME(start time)  进程开始时间
          - TTY 所在终端
          - TIME 进程运行时间
          - CMD产生这个进程的程序名
      - ps -efH 以乔木状列出所有进程(方便看出父子进程关系）
      - ps -u  列出此用户运行的进程
  - top:display Linux processes(实时更新，可交互）
      - linux上进程有5种状态
          - 运行(正在运行或在运行队列中等待)
          - 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 
          - 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 
          - 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 
          - 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) 
      - ps，top工具标识进程的5种状态码: 
          - D 不可中断 uninterruptible sleep (usually IO)
          - R 运行 runnable (on run queue) 
          - S 中断 sleeping  
          - T 停止 traced or stopped 
          - Z 僵死 a defunct (”zombie”) process   (defunct---死人，停业  zombie---僵尸）
      - top 按照cpu使用率显示排在前面的一些进程，结果分析如下
          - 统计信息区(前五行是系统整体的统计信息)          
             - 第一行是任务队列信息同 uptime 命令的执行结果
             - 第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行.
                 - us 用户空间占用CPU百分比
                 - sy 内核空间占用CPU百分比
                 - ni 用户进程空间内改变过优先级的进程占用CPU百分比
                 - d 空闲CPU百分比
                 - wa 等待输入输出的CPU时间百分比
                 - hi
                 - si
             - 最后两行为内存信息
                 - Mem
                     - total 物理内存总量
                     - used 使用的物理内存总量
                     - free 空闲内存总量
                     - buffers 用作内核缓存的内存量
                 - swap 
                     - total 交换区总量
                     - used 使用的交换区总量
                     - free 空闲交换区总量
                     - cached 缓冲的交换区总量。cached 缓存。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。
         - 进程信息区
             - 信息显示
                 - PID 进程id
                 - PPID 父进程id
                 - RUSER Real user name
                 - UID 进程所有者的用户id
                 - USER 进程所有者的用户名
                 - GROUP 进程所有者的组名
                 - TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?
                 - PR 优先级   priority(优先级)
                 - NI nice值。负值表示高优先级，正值表示低优先级
                 - P 最后使用的CPU，仅在多CPU环境下有意义
                 - %CPU 上次更新到现在的CPU时间占用百分比(cpu使用率)
                 - TIME 进程使用的CPU时间总计，单位秒
                 - TIME+ 进程使用的CPU时间总计，单位1/100秒
                 - %MEM 进程使用的物理内存百分比
                 - VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
                 - SWAP 进程使用的虚拟内存中，被换出的大小，单位kb
                 - RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
                 - CODE 可执行代码占用的物理内存大小，单位kb
                 - DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
                 - SHR 共享内存大小，单位kb
                 - nFLT 页面错误次数
                 - nDRT 最后一次写入到现在，被修改过的页面数
                 - S 进程状态。
                     - D=不可中断的睡眠状态
                     - R=运行
                     - S=睡眠
                     - T=跟踪/停止
                     - Z=僵尸进程
                 - COMMAND 命令名/命令行
                 - WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名
                 - Flags 任务标志，参考 sched.h
                 - 默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。
             - 交互
                 - q：退出top

                 - h：显示帮助文档，也就是哪些按键可以使用。按下任意键返回。

                 - B：大写的B，加粗某些信息。

                 - f：在进程列表中添加或删除某些列。 

                 - F：改变进程列表排序所参照的列。默认情况下，是按照%CPU那一列来排序。

                 - u：依照用户来过滤显示。可以输入用户名，按回车。

                 - k：结束某个进程。会让你输入要结束的进程的PID。

                 - s：改变刷新页面的时间。默认地，页面每隔3秒刷新一次。
  
### 管理进程
#### 常规
  - 停止进程
      - Ctrl+C:停止终端中正在运行的进程(终端中复制粘贴Ctrl+Shift+C/V)
      - kill   结束一个进程
          - kill PID1 PID2 PID3  结束进程
          - kill -9 PID       强制立即结束进程
      - killall  结束统一程序的所有进程
          - killall  程序名
    - 关机，重启，halt，reboot都调用了shutdown命令shutdown可以做到定时关机，重启等等
        - halt(停)   关闭系统  = shutdown -h now
            - sudo halt
        - reboot  重启系统   = shutdown -r now
            - sudo reboot
        - poweroff 关机  =shutdown -p
        -  shutdown 是一个独立的命令，它的后面可以指定关机的时间和关机的message，shutdown -h 和 shutdown -p 也就是 halt 和 poweroff，所以，shutdown 就是个加了时间的 halt 或者是 poweroff。
        - h alt 是强制关机，而poweroff 会先给 ACPI （Advanced Configuration and Power Management Interface）一个命令，之后再关机
        - shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，在没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了
        - init是所有进程的祖先﹐它的进程号始终为1﹐所以发送TERM信号给init会终止所有的用户进程﹑守护进程等。shutdown 就是使用这种机制。init定义了8个运行级别(runlevel)，init 0为关机﹐init 1为重启。
#### 进程的前后台转换
  - 后台运行进程
      - & 在后台运行进程(进程与终端相关联，终端停止或用户登出，后台进程也停止)
          - command  &      例如输出信息 [1] 16252，分别表示此终端的后台进程的标号，因为是第一个后台进程，所以标号为1，后面是PID
      - nohup  使后台进程与终端分离   run a command  immune(免疫) to hangups ,with output to a non-tty(输出存放到一个非TTY中)
          - 当用户注销或者网络断开(远程登录网络断了)时，终端会收到HUP(hang up 挂断)信号从而关闭其所有子进程，终端被关闭时也会关闭其子进程。使用nohup命令使程序不受HUP信号影响
          - nohup command   输出信息：ignoring input and appending output to nohup.out
  - 程序前后台转换
      - Ctrl +Z 配合bg  :把 一个正在执行的命令转向后台
          - Ctrl+Z :转到后台，并暂停运行
          - bg (background背景，后台)  :将命令转入后台运行(但是一旦命令开始运行，没有机会输入bg)。假如命令已经在后台，并且暂停着，那么bg命令将其状态改为运行
              - bg  不加参数，默认作用于最近的一个后台进程
              - bg %x      作用于指定标号为x的进程
          - jobs  显示当前终端里后台进程状态
      - fg(foreground前景)：把后台停止的或正在运行的程序转到前台运行
        - fg  不加参数，默认作用于最近的一个后台进程
        - fg %x      作用于指定标号为x的进程
        
        
        
        
***
## 关于终端

### 虚拟终端screen
  - screen   用于在一个终端中打开多个虚拟终端
       - 这个程序通常没有在Linux发行版里预装(sudo apt-get install screen.)
       - screen 开一个虚拟终端并进入，在运行，再开一个
       - Ctrl+D或运行exit退出当前虚拟终端，一直关闭直到显示screen is terminating表明所有的虚拟终端都被关闭了
       - Ctrl+a(在screen中操作)(一下是对帮助页面的解释)
           - Ctrl+a(摁下再松开) + ?   显示帮助界面(在进行所有操作前都要先摁Ctrl a,那些操作区分大小写)
           - clear 表示创建一个新的虚拟终端(及先摁Ctrl a,在摁c)(c)
           - version显示版本号(v)
           - windows 显示当前虚拟终端的列表(^W等效于w(当然之前得先摁ctrl a))
               - bash表示终端的默认名字，*表示当前所在的终端
           - title  重命名当前虚拟终端的名字(A)
           - split(分裂)  分隔当前虚拟终端为多个小虚拟终端(S),操作一次，分为两个，再来一次，分为三个，，，，，，
               - ctrl a之后tab光标调到下半部分，之后Ctrl a之后c为这个部分创建虚拟终端，Ctrl a后X关闭分出来的终端
           - detach(分离，脱离) 使screen所有虚拟终端与当前实际终端分离，重回实际终端，screen在后台运行
               - screen -r +配合虚拟终端编号 重回虚拟终端(screen -ls 列出当前的所有分离了的虚拟终端标号)
 
### 终端命令的延时执行
  - date ：调节时间
      - date 输出当前时间
      - 定制date的输出 ，自定义其的输出，可以选择输出那部分信息，输出格式以及输出的顺序
          - date "+%H"   输出小时
          - date "+%H:%M:%S"  输出时分秒   20:46:38
          - date "+%H时%M分%S"   20时46分38秒，自定义
          - date "+%Y" 年
       - date修改时间
   - at   延时执行一个程序(只能执行一次)
       -  在指定时刻执行程序
           - at 17:12   之后会提示输入要执行的命令，回车继续，Ctrl  D结束，显示EOT(End of Transmission)
           - at 17:12 tomorrow
           - at 17:12  12/10/15  美国日期格式月/日/年
       - 在指定间隔之后执行程序
           - at now +10 minutes  10分钟之后执行 (minutes ,hours,days,weeks,months,years)
       - atq,atrm  列出和删除正在等待执行的at任务
           - atq(at queue)列出正在等待执行的at任务(每次用at延时执行的命令，at都会给它分配一个编号)
           - atrm  +编号        删除at任务(at remove)
   - sleep 
       - 用分号隔开多个命令，使其依次执行(不是管道)
       - touch file ; rm file       创建文件file，之后删除
       - touch file ; sleep 10 ; rm file  创建文件，等待10秒钟，删除这个文件
       - sleep 后数值默认表示秒数，可以用m,h,d(分，时，天)替换
           - touch file ; sleep 10m ;rm file
   - &&,||
       - 类似上面的分号的作用，区别在于，若是&&则前面的命令执行成功，后面的命令才执行，||前面的命令执行失败后面的命令才执行，；不管前面的命令执行成功与否后面的命令都执行
   - crontab  定时重复执行程序，ubuntu下默认安装
       - service cron start/stop/restart    启动，停止和重启动crontab
       - crontab其实只一个命令，用来读取和修改名为crontab的文件。这个crontab文件包含了你要定时执行的程序列表，也包含了执行的时刻
       - 实际上，有两个命令，一个叫crontab,一个叫cron。crontab修改crontab文件，cron用于实际执行定时的程序
       - 相关参数
           - -e:修改crontab文件，没有的话会创建一个
           - -l:显示crontab文件
           - -r:删除crontab文件
       - crontab命令格式    m  h  dom mon dow command--分钟，小时，号，月，周几，命令(在crontab中写要定时执行的命令)
       - 这五个区域要么用数字加符号填充，要么写上一个*号表示任何值
          - m   minutes
          -  h   hour
          - dom   day of month  就是几号
          - mon    month
          - dow day of week   就是周几
          - comman要执行的命令
          - 例子
              - 47 * * * * command	 每个小时的47分都执行command命令，也就是 00点47, 01点47, 02点47, 等等
              - 0 0 * * 1 command	每个礼拜一的凌晨都执行command命令
              - 30 5 1-15 * * command	每个月的1~15日的5点30分都执行command命令
              - 0 0 * * 1,3,4 command	每个礼拜一，礼拜三，礼拜四的凌晨都执行command命令
              - 0 */2 * * * command	每2个小时的整点（0，2，4，6，等等）都执行command命令
              - */10 * * * 1-5 command	每个礼拜一到礼拜五的每个10的倍数的分钟（0，10，20，等等）都执行command命令
              - 你可以自己设计出很多很多不同的组合用法，来实现你的定时程序。
              
### Shell
#### 概念
  - 脚本(Script):是批处理文件的延伸，是一种纯文本保存的程序，一般来说的计算机脚本程序是确定的一系列控制计算机进行运算操作动作组合，在其中可以实现一定的逻辑分支等
  - 可以把不同的终端命令行环境称为不同的Shell
      - sh:(Bourne Shell ).所有shell的祖先
      - bash(Bourne Again Shell) 目前大多数Linux发行版和Mac OS X的默认Shell
      - ksh(Korn Shell):一般在收费的Unix版本上比较多见
      - csh(C Shell):此shell语法有点类似c语言
      - tcsh(Tenex C Shell)csh的优化版本
      - zsh(Z Shell) :zsh : Z Shell 的缩写。比较新近的一个 Shell，集 bash，ksh 和 tcsh 各家之大成。我在公司之前用的是 bash，现在也换成 zsh 了（Github 上有一个 zsh 的配置叫作 oh-my-zsh ，值得拥有）
  - Shell 提供了所有可以让你运行命令的基础功能
  - chsh(change shell) 
      - 如果你想要安装另一个   Shell，比如 ksh，你可以这样安装：
       > sudo apt-get install ksh
         一旦你安装好了 ksh，你还需要将你当前的 Shell（一般来说是 bash ）切换成 ksh，才能生效。
         为了切换Shell，需要用到以下命令： chsh
      - 至于zsh安装配置，见那篇文章
#### 写第一个脚本
  1. 创建脚本文件
      - vim test.sh
          - 如果 test.sh 这个文件不存在，那么会被创建。这里，我们给这个 Shell 脚本文件的后缀是 .sh。这已经成为一种约定俗成的命名惯例了 （sh 就是 shell 的缩写），其实 Shell 脚本文件和普通的文本文件并没有什么区别。我们给它加上 .sh 以强调这是一个 Shell 脚本文件。我们大可以给这个文件起名叫 test （不带 .sh 后缀）。
   2. 指定脚本要使用的shell
       - 在写一个 Shell 脚本时，第一要做的事就是指定要使用哪种 Shell 来 “解析/运行” 它。因为 sh，ksh，bash 等等 Shell 的语法不尽相同。
       - 因为我们的课程中要使用 bash，因此我们在这个 Shell 脚本的第一行写上
           - \#!/bin/bash 
           - 上面这句代码中， /bin/bash 是 bash 程序在大多数 Linux 系统中的存放路径，而最前面的 #! 被称作 Sha-bang，或者 Shebang。       
           - 在计算机科学中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符串行 #! ，其出现在文本文档的第一行的前两个字符。在文档中存在 Shebang 的情况下，类 Unix 操作系统的进程载入器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文档路径作为该解释器的参数。
       - 这一行（ #!/bin/bash ）其实并不是必不可少的，但是它可以保证此脚本会被我们指定的 Shell 执行。如果你没有写这一行，那么此脚本文件会被用户当前的 Shell 所执行。这就可能产生问题：假如你的脚本是用 bash 的语法来写的，而运行这个脚本的用户的 Shell 是 ksh，那么这个脚本就应该不能正常运行了
  3. 写运行命令
  4. 注释
       -  \# 开头
   5. 运行Shell脚本  
       - 给脚本文件添加可执行的权限
           - chmod +x test.sh
           - ./test.sh  运行脚本
   6. 以调试模式运行
       - bash -x test.sh 我们直接调用 bash 这个 Shell 程序，并且给它一个参数 -x （表示以调试模式运行），后面再跟上要调试运行的脚本文件。如此一来，Shell 就会把我们的脚本文件运行时的细节打印出来了，在出现错误时可以帮助我们排查问题所在。 
   7. 创建属于自己的命令
       - 目前，我们的 Shell 脚本文件须要这样运行：./test.sh
       - 那么其他的一些程序（命令其实都是程序），比如 git，pwd，ls，等等，为什么可以直接从不论哪个目录执行（不需要在前面加上 ./ 这样的路径）呢？秘密就在于这些程序存放的目录是在 PATH 这个环境变量中的。PATH 是英语 “ 小路，路； 路线，路程； 途径 ”的意思。PATH 是 Linux 的一个系统变量。这个变量包含了你系统里所有可以被直接执行的程序的路径。如果我们在终端输入：echo $PATH我们就可以看到目前自己系统里的那些“特殊”的目录了。因此，只要你把 test.sh 这个文件拷贝到上述路径列表的任意一个目录（例如 /usr/local/bin ，/usr/bin，等等）中，你就可以在随便什么目录中运行你的 Shell 脚本了。test.sh
   8. 总结
       - 原先我们以为终端命令行只有一种形式，其实有不少类型的终端 ：这就对应了不同的 Shell（外壳程序）。Shell 可以管理命令提示符，还有多种功能，例如命令的历史记录（用 Ctrl+R 来查找），命令的自动补全，等等。
       - 在 Ubuntu 中，默认的 Shell 是 bash，但是也可以安装其他的 Shell，例如 ksh，zsh，等等。
       - 我们可以用 Shell 来自动化一系列命令。首先需要创建一个文件，包含要运行的命令的列表，称之为 Shell 脚本。这也称之为 Shell 编程。
       - 根据使用的 Shell 种类不同，我们有不同的工具来处理 Shell 脚本。我们在本课中使用 bash 来演示，因此在 Shell 脚本文件的开头需要写上：#!/bin/bash
       - 在 Shell 脚本文件里，一般来说只需要把我们要执行的命令一行一行地写入文件。
       - 为了运行 Shell 脚本（也就是运行其中包含的那些命令），需要先给脚本文件添加可执行属性（chmod +x script.sh），然后这样运行： ./script.sh        

              
              
              
***
## 网络方面
### 远程登录
  - 一些概念
      - ssh协议 secure shell
          - shell(俗称壳，用来区别与"核"，是指提供用户使用界面的软件(命令解析器)，类似DOS下面的command和后来的cmd.exe)
          - 不同的加密算法，对称加密与非对称机密，SSH一般都是用非对称机密加密对称加密的密码，之后就用对称加密了
          - 简单的一个过程，服务器产生公钥，私钥，服务器把公钥送给客户机，客户机用公钥加密自己的信息，然后把消息发给服务器，服务器用自己的私钥解密
  - 用ssh来连接远程登录(Debian一族)
      - 配置自己的Linux(前提是此电脑具有自己的公网IP)
          - 安装openSSH  sudo  apt-get install openssh-server
          - 安装完成后自动开启sshd这个精灵进程(Daemon(精灵，恶魔，守护进程) process，或称为守护进程，是一种运行在后台的特殊进程)
          - 手动开启sshd  sudo service ssh start
          - 停止  sudo service ssh stop
          - 对ssh配置做修改 可以修改/etc/ssh/ssh_config  然后运行sudo /etc/init.d/ssh reload或sudo service ssh reload来时修改生效
      - Linux登录远程服务器
          - ssh user@host
              - user  远程服务器上的一个用户名，host远程服务器的IP
              - 若本地用户名与远程用户名一致，可以直接  ssh host
              - SSH 默认端口是22，也就是说登录请求会被送进远程服务器 的22端口
              - ssh -p 250 user@host  使用p参数修改端口，这条命令表示SSH直接连接服务器的250端口
          - 如果第一次登录该服务器，系统会出现类似下面的提示
              - The authenticity (真伪，正确性，真实性，authentication 认证)of host 'host(12.18.429.21)' can't be established.RSA key fingerprint(指纹) is 98:2e:d7:e0:de:9F:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting(yes/no)?
              - 这段话的意思是：无法确认host服务器的真实性，只知道他的公钥指纹，你还想继续连接吗？
              - 公钥指纹(fingerprint):因为公钥长度太长(RSA1024位)，很难比对，所以对其进行MD5计算，将他变成一个128位的指纹，就是上面的一串儿16进制数
              - 远程服务器必须在自己的网站上贴出自己的公钥指纹，以便于用户核对
              - 假定经过风险衡量以后，用户决定接受这个远程服务器的公钥，系统会出现一句提示，表示host主机（也就是我们在操作的电脑）已经得到认可：Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.
              - 当远程服务器的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中（HOME是环境变量，通常保存了用户家目录的绝对路径，比如我的HOME就是/home/oscar）。下次再连接这台服务器时，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个SSH用户都有自己的known_hosts文件。此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程服务器的公钥。
      - windows登录
          - 用putty  在www.putty.org下载

### 文件传输
  - wget ：下载文件
      - wget [参数] [url]使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址(ctrl c停止下载)
      - 怎么事先获得供wget下载的地址呢？你可以用浏览器（比如firefox，chrome），找到要下载的文件，然后在文件上点击鼠标右键，左键点击"复制链接地址"
      - wget -c url  继续一个中断的下载
  - scp   secure copy  把文件从一台电脑拷贝到另一台电脑
      - scp original_file (被拷贝的文件)destination_file(目标文件)
          - 文件表示方式 user@ip:file_name    登录名@域名或ip地址：文件路径  
      - scp image.png    ubuntu@139.199.79.139:/home/ubuntu  把本机文件拷到服务器上(默认22端口)
      - scp ubuntu@139.199.79.139:/home/ubuntu/image.png  file 把服务器上文件拷到本机(默认22端口)
      - scp -P 7821 oscar@89.231.45.67:/home/oscar/images/image.png . 表示从远程电脑（ip地址是89.231.45.67，端口7821）的用户oscar的/home/oscar/images目录下把image.png拷贝到我的电脑中当前文件夹下，名字不变。此处用点号（.）表示当前目录。
  - ftp&sftp:传输文件
      - ftp:file transfer protocol 使用ftp主要分为两种情况：
         - 从公共的FTP服务器下载文件。一般来说，当你点击浏览器上的下载链接时，浏览器就以自动和透明的方式来完成这个操作。这种情况下，连接是匿名的。
         - 从私有的FTP服务器上传或下载文件。当我们从服务器出租商处租用一台服务器作为个人网站之用时，出租商通常会给我们一个FTP的登录名和密码，我们可以连接，以上传及下载文件。这种情况下，连接是需要身份验证的。
      - ftp ftp.debian.org    (连接Debian的ftp服务器ftp//ftp.debian.org)
          - Debian的FTP服务器应该会有所回应，并向你请求输入用户名和密码。对于公共的FTP服务器，用户名一般都填写 anonymous （表示“匿名”）。密码你随便输入什么都会被接受。
          - ftp>表示进入Ftp服务器，命令基本同Linux，如果要在自己电脑上运行命令，命令前加！  eg:ftp>!pwd
          - put：用于上传文件
          - get:用于下载文件
          - 从ftp服务器断开连接：bye,exit,quit或者直接Ctrl D
      - sftp  secure ftp
      - sftp user@ip   eg: sftp ubuntu@wuyulp.cn
          - sftp -oPort 3592 ubuntu@wuyulp.cn  指定端口号
  - rsync :同步备份
      - sudo apt-get installl rsync    一般默认没装
      - rsync命令使我们可以同步两个目录  ，不管这两个目录位于同一台电脑还是不同的电脑（用网络连接）
      - rsync 最常用于增量备份的命令
          - 增量备份：增量备份（incremental backup）是备份的一个类型，指在一次全备份或上一次增量备份后，以后每次的备份只需备份与前一次相比增加或者被修改的文件
      - 备份到同一台电脑的其他目录
          - rsync   -arv    images/    backups/ 将Images目录下的所有文件备份到backups目录下
               - a：保留文件的所有信息，包括权限，修改日期，等等
               - r：递归调用。表示子目录的所有文件也都包括。
               - v：冗余模式。输出详细操作信息。
         - 默认地，rsync在同步时并不会删除目标目录的文件。例如，你的源目录（被同步目录）中删除了一个文件，但是用rsync同步时，它并不会删除同步目录中的相同文件。
             - rsync -arv --delete Images/ backups/  使rsync也同步删除操作
     - 备份到另一台电脑的目录
         - rsync -arv --delete Images/ oscar@89.231.45.67:backups/
      - rsync的强大之处绝不止于此。你可以自己配置rsync，使得它从指定目录（可以是多个目录）备份到指定的ip地址的目录下，而且可以指定哪些类型文件是要备份的，哪些类型不要备份，然后把这一长串命令统一用Shell来写成一个文件（例如取名叫backup），使之可执行（用chmod命令），再把这个文件的路径添加到PATH中。这样你以后不论在哪个目录下输入backup，rsync就帮你自动同步该目录了
      
###  分析网络，隔离防火
  - 概念
      - 为每一个IP地址绑定一个主机名(host name)，注意：这里的主机名其实应该被称为完整主机名： Fully Qualified Domain Name (FQDN)，是由主机名（host name）和域名（domain name）一起构成。我们一般会用主机名或域名来代称FQDN，其实不是那么准确。
      - host name和domain name是不同的概念，有点小复杂。例如，程序员联盟的服务器的完整主机名是www.coderunity.com，这里的www是主机名，coderunity.com是域名。对应的IP地址是58.96.181.197(假想的IP地址
  - host  IP地址和主机名的互相转换     
       - host www.baidu.com/ host baidu.com
       - host 139.199.97.139
  - 自定义解析。 IP地址和主机名的解析是由DNS（Domain Name System，域名解析系统）服务器完成的
      - 你当然不能修改DNS服务器上的主机名和IP地址的对应关系列表（因为有风险，会影响到很多人）。但是你可以自定义你电脑上主机名和IP地址的对应关系。
      - sudo vim /etc/hosts    以root身份打开/etc/hosts 文件：
      - 可以看到一些IP地址和主机名的对应关系，例如：127.0.0.1 对应了localhost。127.0.1.1 对应了oscar-laptop，就是小编电脑的主机名。那么自定义IP地址和主机名之间的解析关系，有什么用呢？当然有用，有的时候，网络上负责解析域名的DNS服务器可能暂时出现故障（很少见），那这时你在地址栏直接输入IP地址可以访问对应网站，但是输入主机名（域名）则不能访问了，因为没有DNS服务器解析，域名是不能被识别的。这时，你自定义在本地Linux系统的/etc/hosts文件中的解析规则就可以发挥作用了。你还是可以访问网站。例如你可以加一条程序员联盟网站的解析对：58.96.181.197 coderunity.com但是这样的方法也有缺陷：假如你的主机的IP地址换了，那你输入域名就不能上那个网站了。所以，一般来说，我们还是靠经常更新解析对的网络上的DNS服务器更好（一般一天更新一次）。对于局域网，这个host文件也是很有用的。例如在自己家里建立的局域网里面，有你的电脑，还有你老爸的电脑。那你不想记住老爸的电脑的IP地址，怎么办呢？可以添加一条解析对，例如：192.168.0.7 father-laptop这样，老爸的电脑的IP地址对应的主机名在你这里就成为father-laptop了，你就可以更方便地访问老爸的电脑。例如，如果在老爸的电脑里你有一个账户叫oscar，那么用之前学的SSH来登录老爸电脑上的oscar账户，就是：ssh oscar@father-laptop就不用输入以下命令了：ssh oscar@192.168.0.7
  - whois:了解域名相关的信息
      - whois wuyulp.cn
  - ifconfig ，netstat:控制和分析网络流量
      - ifconfig：列出网络接口
          - ifconfig(interface configuration)Linux中用于显示或配置网络设备(网络接口卡)的命令
          - 一般来说，你的电脑拥有好几个网络接口，也就是说有多种连接网络的方式
          - 运行ifconfig
              - eth0(有时也会显示enp3so) 对应有线链接(对应你的有线网卡)。有些电脑可能同时有好几条网线连着（有好几个有线接口），例如服务器，那么除了eth0（第一块有线网卡），你还会看到例如eth1，eth2，等等
              - lo 本地回环（Local Loopback的缩写，对应一个虚拟网卡）。每台电脑都应该有这个接口，因为它对应着连向... 自己的链接。这也是我们称之为本地回环的原因：所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但是有时为了某些缘故（可以百度或Google继续探究），我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器指定到回环地址，在浏览器输入 127.0.0.1 就能看到你所架设的Web网站了。但只有你自己能看得到，局域网的其它主机或用户无从知道。
              - wlan0(有时候也会显示wlp2so) 对应Wi-Fi无线连接（对应你的无线网卡）。假如你有好几块无线网卡，那么会看到wlan1，wlan2，等等
              - RX packets(receive packets)  接受包的数目
              - TX  packets(transmit packets) 发送包的数目
              - Link encap:(连接类型)Ethernet(以太网)  HWaddr(网卡的物理地址)
              - inet addr(ip 地址） Bcast(子网，广播地址），Mask(掩码地址）
              - up(表示网卡处在开启状态) RUNNING(代表网卡的网线被接上) MULTICAST(支持组播)MTU(最大传输单元)：1500字节
              - collisions(冲突，碰撞)
         - ifconfig interface state 激活，关闭接口
             - interface--- eth0,wlan0等
             - state  ---up/down 激活，关闭
         - ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255
             - 上面的命令用于给eth0网卡配置IP地址（192.168.120.56），加上子网掩码（255.255.255.0），加上个广播地址（192.168.120.255）。
      - netstat(network  statistics统计) 网络统计            
          - netstat -i 网络接口的统计信息
          - netstat -uta:列出所有开启的连接
              - u：显示UDP连接
              - t:显示tcp连接
              - a:不论连接的状态如何，都显示
              - state列的信息
                  - ESTABLISHED:(established):与远程电脑的连接已建立
                  - TIME_WAIT：连接正在等待网络上封包的处理，一旦处理完毕就开始关闭连接
                  - CLOSE_WAIT:远程服务器终止了连接(也许你太久没什么动作，处在不活跃状态)
                  - CLOSED:连接没有被使用，关闭了
                  - CLOSING:连接正在关闭，但有些数据还没有发送完毕
                  - LISTEN:监听着可能进入的连接，此时连接还没有被使用
              - 端口信息(:冒号之后的信息)
                  - 我们连接其他电脑，可以透过不同的端口（port），不同的端口用处不同。
                  - 你可以加上-n参数，假如你想让端口信息以数字的形式显示，而不是像上图中那样有点看不懂的状态，比如https，nfs，mysql等等。
                  - 80端口是为HTTP（HyperText Transport Protocol，超文本传输协议）开放的，此为上网冲浪使用次数最多的协议，主要用于WWW（World Wide Web，万维网）传输信息的协议。可以通过HTTP地址（即常说的“网址”）加“:80”来访问网站，因为浏览网页服务默认的端口号都是80，因此只需输入网址即可，不用输入“:80”了。
                  - 110端口是为POP3（邮件协议3）服务开放的，用于收发电子邮件
                  - 21端口用于FTP（File Transfer Protocol，文件传输协议）服务，FTP服务主要是为了在两台计算机之间实现文件的上传与下载。上一课我们学习过FTP相当的知识。
          - netstat -lt；列出状态时LISTEN的统计信息
          - netstat -s:列出总结性的统计信息
          - 详见man netstat
  - iptables:参考系防火墙
      - 概念：Linux下著名的防火墙是iptables。它有点年纪了，已经服役十几年。iptables命令可以制定一些规则，规定其他电脑可以使用哪些端口来连接你的电脑（入），以及你的电脑可以连接哪些端口（出）。也可以通过IP地址来过滤
      - 安装  sudo apt-get install iptables(root 使用)
          - iptables -L:显示所有规则
              - chain input:控制进入的网络传输的规则（chain链，束缚）
              - chain forward:控制转发的网络传输的规则 foward:转发
              - chain output:控制出去的网络传输的规则
          - iptables -F,iptables -X,iptables -Z清除已有的iptables规则
          - 开放指定的端口
              - >\#允许本地回环接口(即运行本机访问本机) 
                  iptables  -A INPUT -s 127.0.0.1 -d 127.0.0.1
              - >\#允许已建立的或相关连的通行
                   iptables   A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
              - >\#允许所有本机向外的访问 
               iptables -A OUPUT -j ACCEPT
              - >\# 允许访问22端口 
                iptables    -A INPUT -p tcp --dport 22 -j ACCEPT
              - >\# 允许访问80端口
                iptables     -A INPUT -p tcp --dport 80 -j ACCEPT
              - >\# 允许FTP服务的21和20端口
                 iptables -A INPUT -p tcp --dport 21 -j ACCEPTiptables -A INPUT -p tcp --dport 20 -j ACCEPT
                   \# 如果有其他端口的话，规则也类似，稍微修改上述语句就行。
              - >\# 禁止其他未允许的规则访问（注意：如果22端口未加入允许规则，SSH链接会直接断开。）
                     \#\# 1）.用DROP方法
                   iptables -A INPUT -p tcp -j DROP
                     \#\# 2）.用REJECT方法
                    iptables -A INPUT -j REJECTiptables -A FORWARD -j REJECT
           - 屏蔽IP地址
               - >\# 屏蔽单个IP的命令是
                    iptables -I INPUT -s 123.45.6.7 -j DROP
               ->\# 封整个段，即从123.0.0.1到123.255.255.254的命令
                    iptables -I INPUT -s 123.0.0.0/8 -j DROP
               - >\# 封IP段从123.45.0.1到123.45.255.254的命令
                    iptables -I INPUT -s 124.45.0.0/16 -j DROP
               ->\# 封IP段从123.45.6.1到123.45.6.254的命令是
                    iptables -I INPUT -s 123.45.6.0/24 -j DROP
          - 查看已添加的iptables规则
              - iptables -L -n
          - 删除已添加的iptables规则
              - >\# 将所有iptables以序号标记显示，执行：
                   iptables -L -n --line-numbers
              - >\# 要删除INPUT里序号为8的规则，执行：
                   iptables -D INPUT 8
          - iptables的开机启动及规则保存
              - CentOS上可能会存在安装好iptables后，iptables并不开机自启动，可以执行一下
                  - >chkconfig --level 345 iptables on
                      \# 将其加入开机启动。
                  - >service iptables save
                      \# 保存规则。
              - Debian/Ubuntu上iptables是不会一直保存规则的.需要按如下步骤进行，让网卡关闭时保存iptables规则，启动时加载iptables规则。
                  1. 如果当前用户不是root，即使使用了sudo，也会提示你没有权限，无法保存。所以执行本命令，你必须使用root用户。
                  2. 可以使用sudo -i 快速转到root，使用完成，请使用su username切换到普通帐户
                  3. >为了重启服务器后，规则自动加载，我们创建如下文件:  
                     sudo vim /etc/network/if-pre-up.d/iptables<br>
                     这个iptables文件里的初始内容是:<br>
                     \#!/bin/bash<br>
                           > iptables-save > /etc/iptables.rules<br>
                           > 添加执行权限：<br>
                           > chmod +x /etc/network/if-pre-up.d/iptables<br>
                           > 附上基础规则：<br>
                           > \*filterv<br>
                           > :INPUT ACCEPT [106:85568]<br>
                           > :FORWARD ACCEPT [0:0]<br><br>
                           > :OUTPUT ACCEPT [188:168166]<br>
                           >  :RH-Firewall-1-INPUT - [0:0]<br>
                           > \# 允许本地回环接口(即运行本机访问本机)<br>
                           > -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT<br>
                           > \# 允许已建立的或相关连的通行<br>
                           > -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT<br>
                           > \# 允许所有本机向外的访问<br>
          -A OUTPUT -j ACCEPT<br>
          \# 允许PPTP拨号到外网<br>
          -A INPUT -p tcp -m tcp --dport 1723 -j ACCEPT<br>
           \# 仅特定主机访问Rsync数据同步服务<br>
           -A INPUT -s 8.8.8.8/32 -p tcp -m tcp --dport 873 -j ACCEPT<br>
            \# 仅特定主机访问WDCP管理系统<br>
            -A INPUT -s 6.6.6.6/32 -p tcp -m tcp --dport 8080 -j ACCEPT<br>
            \# 允许访问SSH<br>
           -A INPUT -p tcp -m tcp --dport 1622 -j ACCEPT<br>
             \# 允许访问FTP<br>
             -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT<br>
            -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT<br>
           \# 允许访问网站服务<br>
            -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT<br>
             \# 禁止所有未经允许的连接<br>
              -A INPUT -p tcp -j DROP<br>
            \#注意：如果22端口未加入允许规则，SSH链接会直接断开。<br>
             \#-A INPUT -j REJECT<br>
              \#-A FORWARD -j REJECTCOMMIT<br>
              可以使用一下方法直接载入：<br>
              1.复制上面的规则粘贴到这里,保存文件 sudo vim /etc/iptables.test.rules<br>
              2、把本规则加载,使之生效。注意，iptables不需要重启，加载一次规则就可以。sudo iptables-restore < /etc/iptables.test.rules<br>
              3、查看最新的配置,应该所有的设置都生效了。sudo iptables -L -n<br>
              4、保存生效的配置,让系统重启的时候自动加载有效配置（iptables提供了保存当前运行的规则功能）iptables-save > /etc/iptables.rules<br>
              5.我们也见识到了，iptables的配置相当繁复，普通用户简直望而却步。幸好，有一些软件可以帮助我们减轻痛苦：<br>
      - UFW - Uncomplicated Firewall
          - UFW是Uncomplicated Firewall的缩写，顾名思义这个软件是“不复杂的防火墙”，比iptables简单很多。但ufw并不是在每个Linux发行版中都有的，幸好，Ubuntu中有。
      - nftables
          - 诞生于2008年的nftables设计替代iptables，它提供了一个更简单的Kernel ABI，减少重复代码，改进错误报告，更有效支持过滤规则。
### 源码编译安装软件
  - 概念
      - 有些软件并没有包含在软件仓库中，那么我们只能手动来安装了，也就是只能下载软件的源代码，编译以生成可执行文件
      - 首先尝试找deb安装包。当我们要找的软件不在Ubuntu的软件仓库中时，我们可以试试去软件的官方网站找后缀是.deb（deb是Debian的缩写）的安装包。.deb的安装包只能用于Debian一族的操作系统，包括Ubuntu。而Redhat一族（包括Fedora）用的则是后缀为.rpm（rpm是Redhat Package Manager的缩写）的安装包
      - 有个软件可以帮忙将rpm安装包转换为deb安装包。这个软件是alien(外星人)
          - > \# alien默认没有安装，所以首先要安装它。<br>
               sudo apt-get install alien<br>
                \# 将rpm转换为deb，完成后会生成一个同名的xxxx.deb。<br>
                sudo alien xxxx.rpm<br>
                \# 安装deb安装包。注意，用alien转换的deb包并不能保证100%顺利安装，所以可以找到deb最好直接用deb。<br>
                sudo dpkg -i xxxx.deb<br>
      - 如果你有幸直接在网上找到了软件的deb安装包，那么下载下来，双击安装包（或者用上面的命令行的形式：sudo dpkg -i xxxx.deb）来安装即可。然后一个窗口会弹出，问你是否确定安装，选择“安装”。如果安装过程没出错      ，那很好。如果有错误，一般可能是因为：
          - 也许你下载的deb安装包不符合你的电脑环境。可能位数搞错了，32位和64位有区别的。
          - 也许你没有安装那些依赖软件。因为apt-get工具会帮我们自动下载各种依赖软件，所以不需要我们亲自动手。但现在你需要自己动手安装缺失的依赖软件，可以根据提示信息，缺什么就装什么。
      - 假如实在找不到deb安装包，那么只能：获取软件的源代码,然后自行编译
  - 编译安装
      - 概念
          - 编译安装软件的步骤根据软件的不同有所区别。有些软件的编译安装非常复杂，可能会让你抓狂（特别是一些非标准，非主流的软件），需要很多准备工作
          - 简单来说，编译就是将程序的源代码转换成可执行文件的过程
          - 不过一般安装手册（一般是下载下来源代码时附带的README文本文件）都会说明详细的安装步骤。
          -  在编译之前，你需要安装编译的工具。在Ubuntu下有一个方法可以一次性安装跟编译有关的工具，就是build-essential（build是“构建”或“编译”的意思，essential是“必要的”的意思，顾名思义就是“进行构建/编译所需的必要工具”），运行如下命令安装：
          > sudo apt-get install build-essential
     - 以htop为例
         1. http://hisham.hm/htop/    官网download选择源码下载.tar.gz文件 
         2. 解压并进入其目录，找到configure
         3. 运行configure  ./configure这个程序会分析你的电脑，确认是否编译所必须的所有工具都安装了。它的执行需要些时间，因为要做不少检测。结果检测出现了错误：结果检测出现了错误：结果检测出现了错误：
         > 错误是：没有找到 -lncursesw
            提示信息是：error: You may want to use --disable-unicode or install libncursesw<br>
            意思是：“出错啦：你也许想要用 --disable-unicode 参数 或者 安装libncursesw”。首先小编到网上去找了安装libncursesw的方法，都不行。所以为了快速起见，就不折腾了。直接用第一个建议：用 --disable-unicode 参数。<br>
            重新运行configure            （加上 --disable-unicode 参数）：<br>
             ./configure --disable-unicode<br>
            这会没错误了。<br>
            然后我们就可以开始编译了。用make命令：<br>
            make<br>
             也没错误，编译完成。<br>
              最后一步用make install命令来安装 （需要加上sudo以用root权限来安装软件）：<br>
              sudo make install<br>
           没有问题。安装完成。然后运行htop软件试试：<br>
            htop<br>
     - 一般源码安装的通用步骤
         1. 从网上下载程序的源代码（通常被打包压缩为 .tar.gz 的格式）。

         2. 解压压缩包（tar zxvf xxx.tar.gz）。

         3. 运行解压之后的文件夹里的configure文件： ./configure。

         4.  运行make来编译。

          5. 运行sudo make install完成安装。



         

      
      
      
      
      
      
      
      
      
      
   
   
   

   
           
           
           
       
               
           
           
       
      
        
          
          
  

    
    
            
        
    
    

            
        
    
    
 
    
         
                 
                 


           


        
       
